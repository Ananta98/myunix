diff --git a/Makefile b/Makefile
index 308ddaae..88d0c825 100644
--- a/Makefile
+++ b/Makefile
@@ -17,18 +17,22 @@ includedir = $(prefix)/include
 libdir = $(prefix)/lib
 syslibdir = /lib
 
-SRC_DIRS = $(addprefix $(srcdir)/,src/* crt ldso)
+#MY_OBJS2 = stdlib setjmp regex string crypt ctype errno exit math stdio
+MY_OBJS2 = stdlib string env exit unistd dirent thread conf internal errno stdio math locale multibyte stat setjmp time signal ctype regex prng process mman malloc misc temp fcntl time sched myunix
+MY_OBJS = $(addprefix src/, $(MY_OBJS2))
+#SRC_DIRS = $(addprefix $(srcdir)/,src/* crt ldso)
+# crt1.c crti.c crtn.c Scrt1.c
+SRC_DIRS = $(addprefix $(srcdir)/,$(MY_OBJS))
 BASE_GLOBS = $(addsuffix /*.c,$(SRC_DIRS))
 ARCH_GLOBS = $(addsuffix /$(ARCH)/*.[csS],$(SRC_DIRS))
-BASE_SRCS = $(sort $(wildcard $(BASE_GLOBS)))
-ARCH_SRCS = $(sort $(wildcard $(ARCH_GLOBS)))
+BASE_SRCS = $(sort $(wildcard $(BASE_GLOBS))) $(addprefix $(srcdir)/crt/, crt1.c crti.c crtn.c Scrt1.c)
+ARCH_SRCS = $(sort $(wildcard $(ARCH_GLOBS))) $(sort $(wildcard $(srcdir)/crt/$(ARCH)*.[csS]))
 BASE_OBJS = $(patsubst $(srcdir)/%,%.o,$(basename $(BASE_SRCS)))
 ARCH_OBJS = $(patsubst $(srcdir)/%,%.o,$(basename $(ARCH_SRCS)))
 REPLACED_OBJS = $(sort $(subst /$(ARCH)/,/,$(ARCH_OBJS)))
 ALL_OBJS = $(addprefix obj/, $(filter-out $(REPLACED_OBJS), $(sort $(BASE_OBJS) $(ARCH_OBJS))))
 
 LIBC_OBJS = $(filter obj/src/%,$(ALL_OBJS))
-LDSO_OBJS = $(filter obj/ldso/%,$(ALL_OBJS:%.o=%.lo))
 CRT_OBJS = $(filter obj/crt/%,$(ALL_OBJS))
 
 AOBJS = $(LIBC_OBJS)
@@ -72,8 +76,6 @@ ALL_TOOLS = obj/musl-gcc
 WRAPCC_GCC = gcc
 WRAPCC_CLANG = clang
 
-LDSO_PATHNAME = $(syslibdir)/ld-musl-$(ARCH)$(SUBARCH).so.1
-
 -include config.mak
 
 ifeq ($(ARCH),)
@@ -105,13 +107,15 @@ obj/src/internal/version.h: $(wildcard $(srcdir)/VERSION $(srcdir)/.git)
 
 obj/src/internal/version.o obj/src/internal/version.lo: obj/src/internal/version.h
 
-obj/crt/rcrt1.o obj/ldso/dlstart.lo obj/ldso/dynlink.lo: $(srcdir)/src/internal/dynlink.h $(srcdir)/arch/$(ARCH)/reloc.h
+# obj/crt/rcrt1.o obj/ldso/dlstart.lo obj/ldso/dynlink.lo: $(srcdir)/src/internal/dynlink.h $(srcdir)/arch/$(ARCH)/reloc.h
 
-obj/crt/crt1.o obj/crt/scrt1.o obj/crt/rcrt1.o obj/ldso/dlstart.lo: $(srcdir)/arch/$(ARCH)/crt_arch.h
+# obj/crt/crt1.o obj/crt/scrt1.o obj/crt/rcrt1.o obj/ldso/dlstart.lo: $(srcdir)/arch/$(ARCH)/crt_arch.h
+obj/crt/crt1.o obj/crt/scrt1.o: $(srcdir)/arch/$(ARCH)/crt_arch.h
 
-obj/crt/rcrt1.o: $(srcdir)/ldso/dlstart.c
+#obj/crt/rcrt1.o: $(srcdir)/ldso/dlstart.c
 
-obj/crt/Scrt1.o obj/crt/rcrt1.o: CFLAGS_ALL += -fPIC
+#obj/crt/Scrt1.o obj/crt/rcrt1.o: CFLAGS_ALL += -fPIC
+obj/crt/Scrt1.o: CFLAGS_ALL += -fPIC
 
 OPTIMIZE_SRCS = $(wildcard $(OPTIMIZE_GLOBS:%=$(srcdir)/src/%))
 $(OPTIMIZE_SRCS:$(srcdir)/%.c=obj/%.o) $(OPTIMIZE_SRCS:$(srcdir)/%.c=obj/%.lo): CFLAGS += -O3
@@ -160,8 +164,12 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 	$(CC_CMD)
 
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
-	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+	$(GCC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+#	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+#	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+#	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+#	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
 
 lib/libc.a: $(AOBJS)
 	rm -f $@
diff --git a/arch/i386-myunix/atomic_arch.h b/arch/i386-myunix/atomic_arch.h
new file mode 100644
index 00000000..047fb68d
--- /dev/null
+++ b/arch/i386-myunix/atomic_arch.h
@@ -0,0 +1,108 @@
+#define a_cas a_cas
+static inline int a_cas(volatile int *p, int t, int s)
+{
+	__asm__ __volatile__ (
+		"lock ; cmpxchg %3, %1"
+		: "=a"(t), "=m"(*p) : "a"(t), "r"(s) : "memory" );
+	return t;
+}
+
+#define a_swap a_swap
+static inline int a_swap(volatile int *p, int v)
+{
+	__asm__ __volatile__(
+		"xchg %0, %1"
+		: "=r"(v), "=m"(*p) : "0"(v) : "memory" );
+	return v;
+}
+
+#define a_fetch_add a_fetch_add
+static inline int a_fetch_add(volatile int *p, int v)
+{
+	__asm__ __volatile__(
+		"lock ; xadd %0, %1"
+		: "=r"(v), "=m"(*p) : "0"(v) : "memory" );
+	return v;
+}
+
+#define a_and a_and
+static inline void a_and(volatile int *p, int v)
+{
+	__asm__ __volatile__(
+		"lock ; and %1, %0"
+		: "=m"(*p) : "r"(v) : "memory" );
+}
+
+#define a_or a_or
+static inline void a_or(volatile int *p, int v)
+{
+	__asm__ __volatile__(
+		"lock ; or %1, %0"
+		: "=m"(*p) : "r"(v) : "memory" );
+}
+
+#define a_inc a_inc
+static inline void a_inc(volatile int *p)
+{
+	__asm__ __volatile__(
+		"lock ; incl %0"
+		: "=m"(*p) : "m"(*p) : "memory" );
+}
+
+#define a_dec a_dec
+static inline void a_dec(volatile int *p)
+{
+	__asm__ __volatile__(
+		"lock ; decl %0"
+		: "=m"(*p) : "m"(*p) : "memory" );
+}
+
+#define a_store a_store
+static inline void a_store(volatile int *p, int x)
+{
+	__asm__ __volatile__(
+		"mov %1, %0 ; lock ; orl $0,(%%esp)"
+		: "=m"(*p) : "r"(x) : "memory" );
+}
+
+#define a_barrier a_barrier
+static inline void a_barrier()
+{
+	__asm__ __volatile__( "" : : : "memory" );
+}
+
+#define a_spin a_spin
+static inline void a_spin()
+{
+	__asm__ __volatile__( "pause" : : : "memory" );
+}
+
+#define a_crash a_crash
+static inline void a_crash()
+{
+	__asm__ __volatile__( "hlt" : : : "memory" );
+}
+
+#define a_ctz_64 a_ctz_64
+static inline int a_ctz_64(uint64_t x)
+{
+	int r;
+	__asm__( "bsf %1,%0 ; jnz 1f ; bsf %2,%0 ; add $32,%0\n1:"
+		: "=&r"(r) : "r"((unsigned)x), "r"((unsigned)(x>>32)) );
+	return r;
+}
+
+#define a_ctz_32 a_ctz_32
+static inline int a_ctz_32(uint32_t x)
+{
+	int r;
+	__asm__( "bsf %1,%0" : "=r"(r) : "r"(x) );
+	return r;
+}
+
+#define a_clz_32 a_clz_32
+static inline int a_clz_32(uint32_t x)
+{
+	__asm__( "bsr %1,%0 ; xor $31,%0" : "=r"(x) : "r"(x) );
+	return x;
+}
diff --git a/arch/i386-myunix/bits/alltypes.h.in b/arch/i386-myunix/bits/alltypes.h.in
new file mode 100644
index 00000000..17b45602
--- /dev/null
+++ b/arch/i386-myunix/bits/alltypes.h.in
@@ -0,0 +1,50 @@
+#define _Addr int
+#define _Int64 long long
+#define _Reg int
+
+#include <stdarg.h>
+
+#if __GNUC__ >= 3
+TYPEDEF __builtin_va_list va_list;
+TYPEDEF __builtin_va_list __isoc_va_list;
+#elif defined(__TINYC__)
+TYPEDEF va_list __isoc_va_list;
+#else
+TYPEDEF struct __va_list * va_list;
+TYPEDEF struct __va_list * __isoc_va_list;
+#endif
+
+#ifndef __cplusplus
+#ifdef __WCHAR_TYPE__
+TYPEDEF __WCHAR_TYPE__ wchar_t;
+#else
+TYPEDEF long wchar_t;
+#endif
+#endif
+
+#if defined(__FLT_EVAL_METHOD__) && __FLT_EVAL_METHOD__ == 0
+TYPEDEF float float_t;
+TYPEDEF double double_t;
+#else
+TYPEDEF long double float_t;
+TYPEDEF long double double_t;
+#endif
+
+#if !defined(__cplusplus)
+TYPEDEF struct { _Alignas(8) long long __ll; long double __ld; } max_align_t;
+#elif defined(__GNUC__)
+TYPEDEF struct { __attribute__((__aligned__(8))) long long __ll; long double __ld; } max_align_t;
+#else
+TYPEDEF struct { alignas(8) long long __ll; long double __ld; } max_align_t;
+#endif
+
+TYPEDEF long time_t;
+TYPEDEF long suseconds_t;
+
+TYPEDEF struct { union { int __i[9]; volatile int __vi[9]; unsigned __s[9]; } __u; } pthread_attr_t;
+TYPEDEF struct { union { int __i[6]; volatile int __vi[6]; volatile void *volatile __p[6]; } __u; } pthread_mutex_t;
+TYPEDEF struct { union { int __i[6]; volatile int __vi[6]; volatile void *volatile __p[6]; } __u; } mtx_t;
+TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } pthread_cond_t;
+TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12]; } __u; } cnd_t;
+TYPEDEF struct { union { int __i[8]; volatile int __vi[8]; void *__p[8]; } __u; } pthread_rwlock_t;
+TYPEDEF struct { union { int __i[5]; volatile int __vi[5]; void *__p[5]; } __u; } pthread_barrier_t;
diff --git a/arch/i386-myunix/bits/endian.h b/arch/i386-myunix/bits/endian.h
new file mode 100644
index 00000000..172c338f
--- /dev/null
+++ b/arch/i386-myunix/bits/endian.h
@@ -0,0 +1 @@
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/arch/i386-myunix/bits/fenv.h b/arch/i386-myunix/bits/fenv.h
new file mode 100644
index 00000000..4430009e
--- /dev/null
+++ b/arch/i386-myunix/bits/fenv.h
@@ -0,0 +1,33 @@
+#define FE_INVALID    1
+#define __FE_DENORM   2
+#define FE_DIVBYZERO  4
+#define FE_OVERFLOW   8
+#define FE_UNDERFLOW  16
+#define FE_INEXACT    32
+
+#define FE_ALL_EXCEPT 63
+
+#define FE_TONEAREST  0
+#define FE_DOWNWARD   0x400
+#define FE_UPWARD     0x800
+#define FE_TOWARDZERO 0xc00
+
+typedef unsigned short fexcept_t;
+
+typedef struct {
+	unsigned short __control_word;
+	unsigned short __unused1;
+	unsigned short __status_word;
+	unsigned short __unused2;
+	unsigned short __tags;
+	unsigned short __unused3;
+	unsigned int __eip;
+	unsigned short __cs_selector;
+	unsigned int __opcode:11;
+	unsigned int __unused4:5;
+	unsigned int __data_offset;
+	unsigned short __data_selector;
+	unsigned short __unused5;
+} fenv_t;
+
+#define FE_DFL_ENV      ((const fenv_t *) -1)
diff --git a/arch/i386-myunix/bits/float.h b/arch/i386-myunix/bits/float.h
new file mode 100644
index 00000000..dd6e4029
--- /dev/null
+++ b/arch/i386-myunix/bits/float.h
@@ -0,0 +1,20 @@
+#ifdef __FLT_EVAL_METHOD__
+#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
+#else
+#define FLT_EVAL_METHOD 2
+#endif
+
+#define LDBL_TRUE_MIN 3.6451995318824746025e-4951L
+#define LDBL_MIN     3.3621031431120935063e-4932L
+#define LDBL_MAX     1.1897314953572317650e+4932L
+#define LDBL_EPSILON 1.0842021724855044340e-19L
+
+#define LDBL_MANT_DIG 64
+#define LDBL_MIN_EXP (-16381)
+#define LDBL_MAX_EXP 16384
+
+#define LDBL_DIG 18
+#define LDBL_MIN_10_EXP (-4931)
+#define LDBL_MAX_10_EXP 4932
+
+#define DECIMAL_DIG 21
diff --git a/arch/i386-myunix/bits/io.h b/arch/i386-myunix/bits/io.h
new file mode 100644
index 00000000..dd5bddc9
--- /dev/null
+++ b/arch/i386-myunix/bits/io.h
@@ -0,0 +1,77 @@
+static __inline void outb(unsigned char __val, unsigned short __port)
+{
+	__asm__ volatile ("outb %0,%1" : : "a" (__val), "dN" (__port));
+}
+
+static __inline void outw(unsigned short __val, unsigned short __port)
+{
+	__asm__ volatile ("outw %0,%1" : : "a" (__val), "dN" (__port));
+}
+
+static __inline void outl(unsigned int __val, unsigned short __port)
+{
+	__asm__ volatile ("outl %0,%1" : : "a" (__val), "dN" (__port));
+}
+
+static __inline unsigned char inb(unsigned short __port)
+{
+	unsigned char __val;
+	__asm__ volatile ("inb %1,%0" : "=a" (__val) : "dN" (__port));
+	return __val;
+}
+
+static __inline unsigned short inw(unsigned short __port)
+{
+	unsigned short __val;
+	__asm__ volatile ("inw %1,%0" : "=a" (__val) : "dN" (__port));
+	return __val;
+}
+
+static __inline unsigned int inl(unsigned short __port)
+{
+	unsigned int __val;
+	__asm__ volatile ("inl %1,%0" : "=a" (__val) : "dN" (__port));
+	return __val;
+}
+
+static __inline void outsb(unsigned short __port, const void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; outsb"
+		      : "+S" (__buf), "+c" (__n)
+		      : "d" (__port));
+}
+
+static __inline void outsw(unsigned short __port, const void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; outsw"
+		      : "+S" (__buf), "+c" (__n)
+		      : "d" (__port));
+}
+
+static __inline void outsl(unsigned short __port, const void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; outsl"
+		      : "+S" (__buf), "+c"(__n)
+		      : "d" (__port));
+}
+
+static __inline void insb(unsigned short __port, void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; insb"
+		      : "+D" (__buf), "+c" (__n)
+		      : "d" (__port));
+}
+
+static __inline void insw(unsigned short __port, void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; insw"
+		      : "+D" (__buf), "+c" (__n)
+		      : "d" (__port));
+}
+
+static __inline void insl(unsigned short __port, void *__buf, unsigned long __n)
+{
+	__asm__ volatile ("cld; rep; insl"
+		      : "+D" (__buf), "+c" (__n)
+		      : "d" (__port));
+}
diff --git a/arch/i386-myunix/bits/limits.h b/arch/i386-myunix/bits/limits.h
new file mode 100644
index 00000000..c340ceb2
--- /dev/null
+++ b/arch/i386-myunix/bits/limits.h
@@ -0,0 +1,8 @@
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define PAGESIZE 4096
+#define LONG_BIT 32
+#endif
+
+#define LONG_MAX  0x7fffffffL
+#define LLONG_MAX  0x7fffffffffffffffLL
diff --git a/arch/i386-myunix/bits/mman.h b/arch/i386-myunix/bits/mman.h
new file mode 100644
index 00000000..ba2d6f7a
--- /dev/null
+++ b/arch/i386-myunix/bits/mman.h
@@ -0,0 +1 @@
+#define MAP_32BIT      0x40
diff --git a/arch/i386-myunix/bits/posix.h b/arch/i386-myunix/bits/posix.h
new file mode 100644
index 00000000..30a38714
--- /dev/null
+++ b/arch/i386-myunix/bits/posix.h
@@ -0,0 +1,2 @@
+#define _POSIX_V6_ILP32_OFFBIG  1
+#define _POSIX_V7_ILP32_OFFBIG  1
diff --git a/arch/i386-myunix/bits/reg.h b/arch/i386-myunix/bits/reg.h
new file mode 100644
index 00000000..8bc2582d
--- /dev/null
+++ b/arch/i386-myunix/bits/reg.h
@@ -0,0 +1,19 @@
+#undef __WORDSIZE
+#define __WORDSIZE 32
+#define EBX 0
+#define ECX 1
+#define EDX 2
+#define ESI 3
+#define EDI 4
+#define EBP 5
+#define EAX 6
+#define DS 7
+#define ES 8
+#define FS 9
+#define GS 10
+#define ORIG_EAX 11
+#define EIP 12
+#define CS 13
+#define EFL 14
+#define UESP 15
+#define SS 16
diff --git a/arch/i386-myunix/bits/setjmp.h b/arch/i386-myunix/bits/setjmp.h
new file mode 100644
index 00000000..decd26dc
--- /dev/null
+++ b/arch/i386-myunix/bits/setjmp.h
@@ -0,0 +1 @@
+typedef unsigned long __jmp_buf[6];
diff --git a/arch/i386-myunix/bits/signal.h b/arch/i386-myunix/bits/signal.h
new file mode 100644
index 00000000..9931ee93
--- /dev/null
+++ b/arch/i386-myunix/bits/signal.h
@@ -0,0 +1,142 @@
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#endif
+
+#ifdef _GNU_SOURCE
+enum { REG_GS = 0 };
+#define REG_GS REG_GS
+enum { REG_FS = 1 };
+#define REG_FS REG_FS
+enum { REG_ES = 2 };
+#define REG_ES REG_ES
+enum { REG_DS = 3 };
+#define REG_DS REG_DS
+enum { REG_EDI = 4 };
+#define REG_EDI REG_EDI
+enum { REG_ESI = 5 };
+#define REG_ESI REG_ESI
+enum { REG_EBP = 6 };
+#define REG_EBP REG_EBP
+enum { REG_ESP = 7 };
+#define REG_ESP REG_ESP
+enum { REG_EBX = 8 };
+#define REG_EBX REG_EBX
+enum { REG_EDX = 9 };
+#define REG_EDX REG_EDX
+enum { REG_ECX = 10 };
+#define REG_ECX REG_ECX
+enum { REG_EAX = 11 };
+#define REG_EAX REG_EAX
+enum { REG_TRAPNO = 12 };
+#define REG_TRAPNO REG_TRAPNO
+enum { REG_ERR = 13 };
+#define REG_ERR REG_ERR
+enum { REG_EIP = 14 };
+#define REG_EIP REG_EIP
+enum { REG_CS = 15 };
+#define REG_CS REG_CS
+enum { REG_EFL = 16 };
+#define REG_EFL REG_EFL
+enum { REG_UESP = 17 };
+#define REG_UESP REG_UESP
+enum { REG_SS = 18 };
+#define REG_SS REG_SS
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef int greg_t, gregset_t[19];
+typedef struct _fpstate {
+	unsigned long cw, sw, tag, ipoff, cssel, dataoff, datasel;
+	struct {
+		unsigned short significand[4], exponent;
+	} _st[8];
+	unsigned long status;
+} *fpregset_t;
+struct sigcontext {
+	unsigned short gs, __gsh, fs, __fsh, es, __esh, ds, __dsh;
+	unsigned long edi, esi, ebp, esp, ebx, edx, ecx, eax;
+	unsigned long trapno, err, eip;
+	unsigned short cs, __csh;
+	unsigned long eflags, esp_at_signal;
+	unsigned short ss, __ssh;
+	struct _fpstate *fpstate;
+	unsigned long oldmask, cr2;
+};
+typedef struct {
+	gregset_t gregs;
+	fpregset_t fpregs;
+	unsigned long oldmask, cr2;
+} mcontext_t;
+#else
+typedef struct {
+	unsigned __space[22];
+} mcontext_t;
+#endif
+
+struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+};
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+	unsigned long __fpregs_mem[28];
+} ucontext_t;
+
+#define SA_NOCLDSTOP  1
+#define SA_NOCLDWAIT  2
+#define SA_SIGINFO    4
+#define SA_ONSTACK    0x08000000
+#define SA_RESTART    0x10000000
+#define SA_NODEFER    0x40000000
+#define SA_RESETHAND  0x80000000
+#define SA_RESTORER   0x04000000
+
+#endif
+
+#define SIGHUP    1
+#define SIGINT    2
+#define SIGQUIT   3
+#define SIGILL    4
+#define SIGTRAP   5
+#define SIGABRT   6
+#define SIGIOT    SIGABRT
+#define SIGBUS    7
+#define SIGFPE    8
+#define SIGKILL   9
+#define SIGUSR1   10
+#define SIGSEGV   11
+#define SIGUSR2   12
+#define SIGPIPE   13
+#define SIGALRM   14
+#define SIGTERM   15
+#define SIGSTKFLT 16
+#define SIGCHLD   17
+#define SIGCONT   18
+#define SIGSTOP   19
+#define SIGTSTP   20
+#define SIGTTIN   21
+#define SIGTTOU   22
+#define SIGURG    23
+#define SIGXCPU   24
+#define SIGXFSZ   25
+#define SIGVTALRM 26
+#define SIGPROF   27
+#define SIGWINCH  28
+#define SIGIO     29
+#define SIGPOLL   29
+#define SIGPWR    30
+#define SIGSYS    31
+#define SIGUNUSED SIGSYS
+
+#define _NSIG 65
+
diff --git a/arch/i386-myunix/bits/stat.h b/arch/i386-myunix/bits/stat.h
new file mode 100644
index 00000000..22b19bbf
--- /dev/null
+++ b/arch/i386-myunix/bits/stat.h
@@ -0,0 +1,21 @@
+/* copied from kernel definition, but with padding replaced
+ * by the corresponding correctly-sized userspace types. */
+
+struct stat {
+	dev_t st_dev;
+	int __st_dev_padding;
+	long __st_ino_truncated;
+	mode_t st_mode;
+	nlink_t st_nlink;
+	uid_t st_uid;
+	gid_t st_gid;
+	dev_t st_rdev;
+	int __st_rdev_padding;
+	off_t st_size;
+	blksize_t st_blksize;
+	blkcnt_t st_blocks;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	ino_t st_ino;
+};
diff --git a/arch/i386-myunix/bits/stdint.h b/arch/i386-myunix/bits/stdint.h
new file mode 100644
index 00000000..d1b27121
--- /dev/null
+++ b/arch/i386-myunix/bits/stdint.h
@@ -0,0 +1,20 @@
+typedef int32_t int_fast16_t;
+typedef int32_t int_fast32_t;
+typedef uint32_t uint_fast16_t;
+typedef uint32_t uint_fast32_t;
+
+#define INT_FAST16_MIN  INT32_MIN
+#define INT_FAST32_MIN  INT32_MIN
+
+#define INT_FAST16_MAX  INT32_MAX
+#define INT_FAST32_MAX  INT32_MAX
+
+#define UINT_FAST16_MAX UINT32_MAX
+#define UINT_FAST32_MAX UINT32_MAX
+
+#define INTPTR_MIN      INT32_MIN
+#define INTPTR_MAX      INT32_MAX
+#define UINTPTR_MAX     UINT32_MAX
+#define PTRDIFF_MIN     INT32_MIN
+#define PTRDIFF_MAX     INT32_MAX
+#define SIZE_MAX        UINT32_MAX
diff --git a/arch/i386-myunix/bits/syscall.h.in b/arch/i386-myunix/bits/syscall.h.in
new file mode 100644
index 00000000..60e5ed09
--- /dev/null
+++ b/arch/i386-myunix/bits/syscall.h.in
@@ -0,0 +1,31 @@
+#define __NR_exit 1
+
+#define __NR_read 3
+#define __NR_write 4
+#define __NR_open 5
+#define __NR_close 6
+#define __NR_waitpid 7
+
+#define __NR_unlink 10
+#define __NR_execve 11
+
+#define __NR_lseek 19
+
+#define __NR_getpid 20
+
+#define __NR_mkdir 39
+
+#define __NR_dup 41
+
+#define __NR_dup2 63
+
+#define __NR_readdir		 89
+
+#define __NR_clone 120
+
+#define __NR_sched_yield		158
+
+#define __NR_dup3 330
+
+#define __NR_mmap_anon 512
+#define __NR_munmap 513
diff --git a/arch/i386-myunix/bits/user.h b/arch/i386-myunix/bits/user.h
new file mode 100644
index 00000000..33fea986
--- /dev/null
+++ b/arch/i386-myunix/bits/user.h
@@ -0,0 +1,44 @@
+#undef __WORDSIZE
+#define __WORDSIZE 32
+
+typedef struct user_fpregs_struct {
+	long cwd, swd, twd, fip, fcs, foo, fos, st_space[20];
+} elf_fpregset_t;
+
+typedef struct user_fpxregs_struct {
+	unsigned short cwd, swd, twd, fop;
+	long fip, fcs, foo, fos, mxcsr, reserved;
+	long st_space[32], xmm_space[32], padding[56];
+} elf_fpxregset_t;
+
+struct user_regs_struct {
+	long ebx, ecx, edx, esi, edi, ebp, eax, xds, xes, xfs, xgs;
+	long orig_eax, eip, xcs, eflags, esp, xss;
+};
+
+#define ELF_NGREG 17
+typedef unsigned long elf_greg_t, elf_gregset_t[ELF_NGREG];
+
+struct user {
+	struct user_regs_struct		regs;
+	int				u_fpvalid;
+	struct user_fpregs_struct	i387;
+	unsigned long			u_tsize;
+	unsigned long			u_dsize;
+	unsigned long			u_ssize;
+	unsigned long			start_code;
+	unsigned long			start_stack;
+	long				signal;
+	int				reserved;
+	struct user_regs_struct		*u_ar0;
+	struct user_fpregs_struct	*u_fpstate;
+	unsigned long			magic;
+	char				u_comm[32];
+	int				u_debugreg[8];
+};
+
+#define PAGE_MASK		(~(PAGESIZE-1))
+#define NBPG			PAGESIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
diff --git a/arch/i386-myunix/crt_arch.h b/arch/i386-myunix/crt_arch.h
new file mode 100644
index 00000000..43c8477a
--- /dev/null
+++ b/arch/i386-myunix/crt_arch.h
@@ -0,0 +1,16 @@
+__asm__(
+".text\n"
+".weak _DYNAMIC \n"
+".hidden _DYNAMIC \n"
+".global " START "\n"
+START ":\n"
+"	xor %ebp,%ebp \n"
+"	mov %esp,%eax \n"
+"	and $-16,%esp \n"
+"	push %eax \n"
+"	push %eax \n"
+"	call 1f \n"
+"1:	addl $_DYNAMIC-1b,(%esp) \n"
+"	push %eax \n"
+"	call " START "_c \n"
+);
diff --git a/arch/i386-myunix/pthread_arch.h b/arch/i386-myunix/pthread_arch.h
new file mode 100644
index 00000000..7bd2c3b0
--- /dev/null
+++ b/arch/i386-myunix/pthread_arch.h
@@ -0,0 +1,4 @@
+static inline struct pthread *__pthread_self()
+{
+	return (struct pthread *)0xDEADC0DE;
+}
diff --git a/arch/i386-myunix/reloc.h b/arch/i386-myunix/reloc.h
new file mode 100644
index 00000000..032f454b
--- /dev/null
+++ b/arch/i386-myunix/reloc.h
@@ -0,0 +1,23 @@
+#define LDSO_ARCH "i386"
+
+#define REL_SYMBOLIC    R_386_32
+#define REL_OFFSET      R_386_PC32
+#define REL_GOT         R_386_GLOB_DAT
+#define REL_PLT         R_386_JMP_SLOT
+#define REL_RELATIVE    R_386_RELATIVE
+#define REL_COPY        R_386_COPY
+#define REL_DTPMOD      R_386_TLS_DTPMOD32
+#define REL_DTPOFF      R_386_TLS_DTPOFF32
+#define REL_TPOFF       R_386_TLS_TPOFF
+#define REL_TPOFF_NEG   R_386_TLS_TPOFF32
+#define REL_TLSDESC     R_386_TLS_DESC
+
+#define CRTJMP(pc,sp) __asm__ __volatile__( \
+	"mov %1,%%esp ; jmp *%0" : : "r"(pc), "r"(sp) : "memory" )
+
+#define GETFUNCSYM(fp, sym, got) __asm__ ( \
+	".hidden " #sym "\n" \
+	"	call 1f\n" \
+	"1:	addl $" #sym "-.,(%%esp)\n" \
+	"	pop %0" \
+	: "=r"(*fp) : : "memory" )
diff --git a/arch/i386-myunix/syscall_arch.h b/arch/i386-myunix/syscall_arch.h
new file mode 100644
index 00000000..446cb501
--- /dev/null
+++ b/arch/i386-myunix/syscall_arch.h
@@ -0,0 +1,79 @@
+static inline long __syscall0(long n)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ (
+		"int $0x80\n"
+		: "=a" (__ret)
+		: "a" ((long)n)
+	);
+	return __ret;
+}
+
+static inline long __syscall1(long n, long a1)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ (
+		"int $0x80\n"
+		: "=a" (__ret)
+		: "a" (n), "b" (a1)
+	);
+	return __ret;
+}
+
+static inline long __syscall2(long n, long a1, long a2)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ (
+		"int $0x80\n"
+		: "=a" (__ret)
+		: "a" (n), "b" (a1), "c" (a2)
+	);
+	return __ret;
+}
+
+static inline long __syscall3(long n, long a1, long a2, long a3)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ (
+		"int $0x80\n"
+		: "=a" (__ret)
+		: "a" (n), "b" (a1), "c" (a2), "d" (a3)
+	);
+	return __ret;
+}
+/*
+static inline long __syscall4(long n, long a1, long a2, long a3, long a4)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ (".hidden __vsyscall ; call __vsyscall" : "=a"(__ret) : "a"(n), "d"(a1), "c"(a2), "D"(a3), "S"(a4) : "memory");
+	return __ret;
+}
+
+static inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)
+{
+	unsigned long __ret;
+	__asm__ __volatile__ ("push %6 ; .hidden __vsyscall ; call __vsyscall ; add $4,%%esp" : "=a"(__ret) : "a"(n), "d"(a1), "c"(a2), "D"(a3), "S"(a4), "g"(a5) : "memory");
+	return __ret;
+}
+*/
+static inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
+{
+	unsigned long __ret;
+	// FIXME: what is this used for ? ( we don't have a good way to pass them yet )
+/*	__asm__ __volatile__ (
+		"int $0x80\n"
+		: "=a" (__ret)
+		: "a" (n), "b" (a1), "c" (a2), "d" (a3)
+	);*/
+	__asm__ __volatile__ (
+		"int $0\n"
+	);
+	return __ret;
+}
+/*
+#define VDSO_USEFUL
+#define VDSO_CGT_SYM "__vdso_clock_gettime"
+#define VDSO_CGT_VER "LINUX_2.6"
+
+#define SYSCALL_USE_SOCKETCALL
+*/
diff --git a/configure b/configure
index 1e59c461..dff6e383 100755
--- a/configure
+++ b/configure
@@ -313,6 +313,7 @@ printf "%s\n" "$target"
 #
 case "$target" in
 # Catch these early to simplify matching for 32-bit archs
+i386-myunix) ARCH=i386-myunix ;;
 arm*) ARCH=arm ;;
 aarch64*) ARCH=aarch64 ;;
 i?86-nt32*) ARCH=nt32 ;;
diff --git a/crt/i386-myunix/crti.s b/crt/i386-myunix/crti.s
new file mode 100644
index 00000000..d2682a20
--- /dev/null
+++ b/crt/i386-myunix/crti.s
@@ -0,0 +1,9 @@
+.section .init
+.global _init
+_init:
+	sub $12,%esp
+
+.section .fini
+.global _fini
+_fini:
+	sub $12,%esp
diff --git a/crt/i386-myunix/crtn.s b/crt/i386-myunix/crtn.s
new file mode 100644
index 00000000..f3b61e01
--- /dev/null
+++ b/crt/i386-myunix/crtn.s
@@ -0,0 +1,7 @@
+.section .init
+	add $12,%esp
+	ret
+
+.section .fini
+	add $12,%esp
+	ret
diff --git a/include/dirent.h b/include/dirent.h
index e0a8fe6a..b7b9f9d2 100644
--- a/include/dirent.h
+++ b/include/dirent.h
@@ -16,11 +16,12 @@ extern "C" {
 #include <bits/alltypes.h>
 
 typedef struct __dirstream DIR;
-
+/*
 #define _DIRENT_HAVE_D_RECLEN
 #define _DIRENT_HAVE_D_OFF
+*/
 #define _DIRENT_HAVE_D_TYPE
-
+/*
 struct dirent {
 	ino_t d_ino;
 	off_t d_off;
@@ -28,6 +29,12 @@ struct dirent {
 	unsigned char d_type;
 	char d_name[256];
 };
+*/
+struct dirent {
+	ino_t d_ino;
+	unsigned char d_type;
+	char d_name[256];
+};
 
 #define d_fileno d_ino
 
diff --git a/include/stdarg.h b/include/stdarg.h
deleted file mode 100644
index 3256f805..00000000
--- a/include/stdarg.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef _STDARG_H
-#define _STDARG_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define __NEED_va_list
-
-#include <bits/alltypes.h>
-
-#define va_start(v,l)   __builtin_va_start(v,l)
-#define va_end(v)       __builtin_va_end(v)
-#define va_arg(v,l)     __builtin_va_arg(v,l)
-#define va_copy(d,s)    __builtin_va_copy(d,s)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/aio/aio.c b/src/aio/aio.c
index aafd8e8c..903e4f06 100644
--- a/src/aio/aio.c
+++ b/src/aio/aio.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <aio.h>
 #include <pthread.h>
 #include <semaphore.h>
@@ -10,6 +12,7 @@
 #include "libc.h"
 #include "pthread_impl.h"
 
+*/
 /* The following is a threads-based implementation of AIO with minimal
  * dependence on implementation details. Most synchronization is
  * performed with pthread primitives, but atomics and futex operations
@@ -40,7 +43,7 @@
  * to be async-signal safe. All aio worker threads run with all signals
  * blocked permanently.
  */
-
+/*
 struct aio_args {
 	struct aiocb *cb;
 	int op;
@@ -112,10 +115,10 @@ static void __aio_unref_queue(struct aio_queue *q)
 		return;
 	}
 
-	/* This is potentially the last reference, but a new reference
+*/	/* This is potentially the last reference, but a new reference
 	 * may arrive since we cannot free the queue object without first
 	 * taking the maplock, which requires releasing the queue lock. */
-	pthread_mutex_unlock(&q->lock);
+/*	pthread_mutex_unlock(&q->lock);
 	pthread_rwlock_wrlock(&maplock);
 	pthread_mutex_lock(&q->lock);
 	if (q->ref == 1) {
@@ -141,14 +144,14 @@ static void cleanup(void *ctx)
 	struct aiocb *cb = at->cb;
 	struct sigevent sev = cb->aio_sigevent;
 
-	/* There are four potential types of waiters we could need to wake:
+*/	/* There are four potential types of waiters we could need to wake:
 	 *   1. Callers of aio_cancel/close.
 	 *   2. Callers of aio_suspend with a single aiocb.
 	 *   3. Callers of aio_suspend with a list.
 	 *   4. AIO worker threads waiting for sequenced operations.
 	 * Types 1-3 are notified via atomics/futexes, mainly for AS-safety
 	 * considerations. Type 4 is notified later via a cond var. */
-
+/*
 	cb->__ret = at->ret;
 	if (a_swap(&at->running, 0) < 0)
 		__wake(&at->running, -1, 1);
@@ -163,8 +166,8 @@ static void cleanup(void *ctx)
 	if (at->prev) at->prev->next = at->next;
 	else q->head = at->next;
 
-	/* Signal aio worker threads waiting for sequenced operations. */
-	pthread_cond_broadcast(&q->cond);
+*/	/* Signal aio worker threads waiting for sequenced operations. */
+/*	pthread_cond_broadcast(&q->cond);
 
 	__aio_unref_queue(q);
 
@@ -224,8 +227,8 @@ static void *io_thread_func(void *ctx)
 
 	pthread_cleanup_push(cleanup, &at);
 
-	/* Wait for sequenced operations. */
-	if (op!=LIO_READ && (op!=LIO_WRITE || q->append)) {
+*/	/* Wait for sequenced operations. */
+/*	if (op!=LIO_READ && (op!=LIO_WRITE || q->append)) {
 		for (;;) {
 			for (p=at.next; p && p->op!=LIO_WRITE; p=p->next);
 			if (!p) break;
@@ -334,8 +337,8 @@ int aio_cancel(int fd, struct aiocb *cb)
 	struct aio_thread *p;
 	struct aio_queue *q;
 
-	/* Unspecified behavior case. Report an error. */
-	if (cb && fd != cb->aio_fildes) {
+*/	/* Unspecified behavior case. Report an error. */
+/*	if (cb && fd != cb->aio_fildes) {
 		errno = EINVAL;
 		return -1;
 	}
@@ -350,8 +353,8 @@ int aio_cancel(int fd, struct aiocb *cb)
 
 	for (p = q->head; p; p = p->next) {
 		if (cb && cb != p->cb) continue;
-		/* Transition target from running to running-with-waiters */
-		if (a_cas(&p->running, 1, -1)) {
+*/		/* Transition target from running to running-with-waiters */
+/*		if (a_cas(&p->running, 1, -1)) {
 			pthread_cancel(p->td);
 			__wait(&p->running, 0, -1, 1);
 			if (p->err == ECANCELED) ret = AIO_CANCELED;
@@ -377,3 +380,4 @@ LFS64(aio_fsync);
 LFS64(aio_read);
 LFS64(aio_write);
 LFS64(aio_return);
+*/
diff --git a/src/aio/aio_suspend.c b/src/aio/aio_suspend.c
index 08fb5ddc..13a36500 100644
--- a/src/aio/aio_suspend.c
+++ b/src/aio/aio_suspend.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <aio.h>
 #include <errno.h>
 #include <time.h>
@@ -56,8 +58,8 @@ int aio_suspend(const struct aiocb *const cbs[], int cnt, const struct timespec
 			if (!tid) tid = __pthread_self()->tid;
 			expect = a_cas(pfut, 0, tid);
 			if (!expect) expect = tid;
-			/* Need to recheck the predicate before waiting. */
-			for (i=0; i<cnt; i++)
+*/			/* Need to recheck the predicate before waiting. */
+/*			for (i=0; i<cnt; i++)
 				if (cbs[i] && aio_error(cbs[i]) != EINPROGRESS)
 					return 0;
 			break;
@@ -77,3 +79,4 @@ int aio_suspend(const struct aiocb *const cbs[], int cnt, const struct timespec
 }
 
 LFS64(aio_suspend);
+*/
diff --git a/src/aio/lio_listio.c b/src/aio/lio_listio.c
index bd37767e..e46972a7 100644
--- a/src/aio/lio_listio.c
+++ b/src/aio/lio_listio.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <aio.h>
 #include <errno.h>
 #include <unistd.h>
@@ -142,3 +144,4 @@ int lio_listio(int mode, struct aiocb *restrict const *restrict cbs, int cnt, st
 }
 
 LFS64(lio_listio);
+*/
diff --git a/src/conf/sysconf.c b/src/conf/sysconf.c
index 9ce330a5..713334f9 100644
--- a/src/conf/sysconf.c
+++ b/src/conf/sysconf.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <limits.h>
 #include <errno.h>
@@ -49,7 +51,7 @@ long sysconf(int name)
 		[_SC_SHARED_MEMORY_OBJECTS] = VER,
 		[_SC_AIO_LISTIO_MAX] = -1,
 		[_SC_AIO_MAX] = -1,
-		[_SC_AIO_PRIO_DELTA_MAX] = JT_ZERO, /* ?? */
+		[_SC_AIO_PRIO_DELTA_MAX] = JT_ZERO, *//* ?? *//*
 		[_SC_DELAYTIMER_MAX] = _POSIX_DELAYTIMER_MAX,
 		[_SC_MQ_OPEN_MAX] = -1,
 		[_SC_MQ_PRIO_MAX] = JT_MQ_PRIO_MAX,
@@ -215,3 +217,4 @@ long sysconf(int name)
 	}
 	return values[name];
 }
+*/
diff --git a/src/dirent/__getdents.c b/src/dirent/__getdents.c
index 1acd5a69..c8f07904 100644
--- a/src/dirent/__getdents.c
+++ b/src/dirent/__getdents.c
@@ -1,3 +1,6 @@
+/*
+// TODO: implement
+
 #include <dirent.h>
 #include "syscall.h"
 #include "libc.h"
@@ -10,3 +13,4 @@ int __getdents(int fd, struct dirent *buf, size_t len)
 weak_alias(__getdents, getdents);
 
 LFS64(getdents);
+*/
diff --git a/src/dirent/readdir.c b/src/dirent/readdir.c
index 2cf0632c..6378fc5b 100644
--- a/src/dirent/readdir.c
+++ b/src/dirent/readdir.c
@@ -9,7 +9,7 @@ int __getdents(int, struct dirent *, size_t);
 struct dirent *readdir(DIR *dir)
 {
 	struct dirent *de;
-	
+/*
 	if (dir->buf_pos >= dir->buf_end) {
 		int len = __syscall(SYS_getdents, dir->fd, dir->buf, sizeof dir->buf);
 		if (len <= 0) {
@@ -23,6 +23,22 @@ struct dirent *readdir(DIR *dir)
 	dir->buf_pos += de->d_reclen;
 	dir->tell = de->d_off;
 	return de;
+*/
+	de = malloc(sizeof(struct dirent));
+	if (de == 0) {
+		return 0;
+	} else {
+		int i = __syscall(SYS_readdir, dir->fd, dir->tell, de);
+		if (i == 1) {
+			dir->tell++;
+			return de;
+		} else {
+			if (i != -ENOENT) {
+				errno = -i;
+			}
+			return 0;
+		}
+	}
 }
 
 LFS64(readdir);
diff --git a/src/dirent/readdir_r.c b/src/dirent/readdir_r.c
index daa6c6ed..c38b67d4 100644
--- a/src/dirent/readdir_r.c
+++ b/src/dirent/readdir_r.c
@@ -18,7 +18,8 @@ int readdir_r(DIR *restrict dir, struct dirent *restrict buf, struct dirent **re
 		return ret;
 	}
 	errno = errno_save;
-	if (de) memcpy(buf, de, de->d_reclen);
+//	if (de) memcpy(buf, de, de->d_reclen);
+	if (de) memcpy(buf, de, sizeof(de));
 	else buf = NULL;
 
 	UNLOCK(dir->lock);
diff --git a/src/dirent/scandir.c b/src/dirent/scandir.c
index 3af2b50f..693dd1f2 100644
--- a/src/dirent/scandir.c
+++ b/src/dirent/scandir.c
@@ -26,9 +26,11 @@ int scandir(const char *path, struct dirent ***res,
 			if (!tmp) break;
 			names = tmp;
 		}
-		names[cnt] = malloc(de->d_reclen);
+		//names[cnt] = malloc(de->d_reclen);
+		names[cnt] = malloc(sizeof(de));
 		if (!names[cnt]) break;
-		memcpy(names[cnt++], de, de->d_reclen);
+		//memcpy(names[cnt++], de, de->d_reclen);
+		memcpy(names[cnt++], de, sizeof(de));
 	}
 
 	closedir(d);
diff --git a/src/env/__init_tls.c b/src/env/__init_tls.c
index b125eb1f..04446012 100644
--- a/src/env/__init_tls.c
+++ b/src/env/__init_tls.c
@@ -7,7 +7,7 @@
 #include "libc.h"
 #include "atomic.h"
 #include "syscall.h"
-
+/*
 int __init_tp(void *p)
 {
 	pthread_t td = p;
@@ -73,10 +73,11 @@ typedef Elf64_Phdr Phdr;
 
 __attribute__((__weak__, __visibility__("hidden")))
 extern const size_t _DYNAMIC[];
-
+*/
 static void static_init_tls(size_t *aux)
 {
-	unsigned char *p;
+	// TODO: implement
+/*	unsigned char *p;
 	size_t n;
 	Phdr *phdr, *tls_phdr=0;
 	size_t base = 0;
@@ -121,16 +122,17 @@ static void static_init_tls(size_t *aux)
 			SYS_mmap2,
 			0, libc.tls_size, PROT_READ|PROT_WRITE,
 			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
-		/* -4095...-1 cast to void * will crash on dereference anyway,
+*/		/* -4095...-1 cast to void * will crash on dereference anyway,
 		 * so don't bloat the init code checking for error codes and
 		 * explicitly calling a_crash(). */
-	} else {
+/*	} else {
 		mem = builtin_tls;
 	}
 
-	/* Failure to initialize thread pointer is always fatal. */
-	if (__init_tp(__copy_tls(mem)) < 0)
-		a_crash();
+*/	/* Failure to initialize thread pointer is always fatal. */
+//	if (__init_tp(__copy_tls(mem)) < 0)
+//		a_crash();
 }
 
 weak_alias(static_init_tls, __init_tls);
+
diff --git a/src/env/__libc_start_main.c b/src/env/__libc_start_main.c
index 2d758af7..76985d9a 100644
--- a/src/env/__libc_start_main.c
+++ b/src/env/__libc_start_main.c
@@ -24,23 +24,27 @@ void __init_libc(char **envp, char *pn)
 	size_t i, *auxv, aux[AUX_CNT] = { 0 };
 	__environ = envp;
 	for (i=0; envp[i]; i++);
-	libc.auxv = auxv = (void *)(envp+i+1);
-	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
-	__hwcap = aux[AT_HWCAP];
-	__sysinfo = aux[AT_SYSINFO];
-	libc.page_size = aux[AT_PAGESZ];
+//	libc.auxv = auxv = (void *)(envp+i+1);
+//	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
+//	__hwcap = aux[AT_HWCAP];
+//	__sysinfo = aux[AT_SYSINFO];
+//	libc.page_size = aux[AT_PAGESZ];
+	libc.page_size = 4096;
 
-	if (!pn) pn = (void*)aux[AT_EXECFN];
+//	if (!pn) pn = (void*)aux[AT_EXECFN];
 	if (!pn) pn = "";
 	__progname = __progname_full = pn;
 	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
 
 	__init_tls(aux);
-	__init_ssp((void *)aux[AT_RANDOM]);
+//	__init_ssp((void *)aux[AT_RANDOM]);
+	__init_ssp(NULL);
 
-	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
-		&& !aux[AT_SECURE]) return;
+//	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
+//		&& !aux[AT_SECURE]) return;
 
+/*
+// TODO: implement
 	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
 #ifdef SYS_poll
 	__syscall(SYS_poll, pfd, 3, 0);
@@ -50,6 +54,7 @@ void __init_libc(char **envp, char *pn)
 	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
 		if (__sys_open("/dev/null", O_RDWR)<0)
 			a_crash();
+*/
 	libc.secure = 1;
 }
 
diff --git a/src/env/__stack_chk_fail.c b/src/env/__stack_chk_fail.c
index 4de82fd9..4b58a3d7 100644
--- a/src/env/__stack_chk_fail.c
+++ b/src/env/__stack_chk_fail.c
@@ -9,7 +9,7 @@ void __init_ssp(void *entropy)
 	if (entropy) memcpy(&__stack_chk_guard, entropy, sizeof(uintptr_t));
 	else __stack_chk_guard = (uintptr_t)&__stack_chk_guard * 1103515245;
 
-	__pthread_self()->CANARY = __stack_chk_guard;
+//	__pthread_self()->CANARY = __stack_chk_guard;
 }
 
 void __stack_chk_fail(void)
diff --git a/src/errno/__errno_location.c b/src/errno/__errno_location.c
index 7172a1be..2edb3974 100644
--- a/src/errno/__errno_location.c
+++ b/src/errno/__errno_location.c
@@ -1,6 +1,9 @@
 #include "pthread_impl.h"
 
+int __errno;
+
 int *__errno_location(void)
 {
-	return &__pthread_self()->errno_val;
+//	return &__pthread_self()->errno_val;
+	return &__errno;
 }
diff --git a/src/exit/_Exit.c b/src/exit/_Exit.c
index 7a6115c7..e056792c 100644
--- a/src/exit/_Exit.c
+++ b/src/exit/_Exit.c
@@ -3,6 +3,6 @@
 
 _Noreturn void _Exit(int ec)
 {
-	__syscall(SYS_exit_group, ec);
+//	__syscall(SYS_exit_group, ec);
 	for (;;) __syscall(SYS_exit, ec);
 }
diff --git a/src/exit/abort.c b/src/exit/abort.c
index ecc0f735..19fd94a1 100644
--- a/src/exit/abort.c
+++ b/src/exit/abort.c
@@ -6,9 +6,9 @@
 
 _Noreturn void abort(void)
 {
-	raise(SIGABRT);
-	__block_all_sigs(0);
+//	raise(SIGABRT);
+//	__block_all_sigs(0);
 	a_crash();
-	raise(SIGKILL);
+//	raise(SIGKILL);
 	_Exit(127);
 }
diff --git a/src/fcntl/fcntl.c b/src/fcntl/fcntl.c
index ce615d0e..dfedeea9 100644
--- a/src/fcntl/fcntl.c
+++ b/src/fcntl/fcntl.c
@@ -7,6 +7,8 @@
 
 int fcntl(int fd, int cmd, ...)
 {
+/*
+// TODO: implement
 	unsigned long arg;
 	va_list ap;
 	va_start(ap, cmd);
@@ -46,4 +48,6 @@ int fcntl(int fd, int cmd, ...)
 	default:
 		return syscall(SYS_fcntl, fd, cmd, arg);
 	}
+*/
+	return -1;
 }
diff --git a/src/fcntl/open.c b/src/fcntl/open.c
index 3928a6e6..79d0285c 100644
--- a/src/fcntl/open.c
+++ b/src/fcntl/open.c
@@ -15,8 +15,9 @@ int open(const char *filename, int flags, ...)
 	}
 
 	int fd = __sys_open_cp(filename, flags, mode);
-	if (fd>=0 && (flags & O_CLOEXEC))
-		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+	// TODO: implement
+//	if (fd>=0 && (flags & O_CLOEXEC))
+//		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
 
 	return __syscall_ret(fd);
 }
diff --git a/src/fcntl/openat.c b/src/fcntl/openat.c
index e741336c..c47d86cf 100644
--- a/src/fcntl/openat.c
+++ b/src/fcntl/openat.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <fcntl.h>
 #include <stdarg.h>
 #include "syscall.h"
@@ -18,3 +20,4 @@ int openat(int fd, const char *filename, int flags, ...)
 }
 
 LFS64(openat);
+*/
diff --git a/src/fcntl/posix_fadvise.c b/src/fcntl/posix_fadvise.c
index c1a0ef5a..554c6ecb 100644
--- a/src/fcntl/posix_fadvise.c
+++ b/src/fcntl/posix_fadvise.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <fcntl.h>
 #include "syscall.h"
 #include "libc.h"
@@ -5,10 +7,10 @@
 int posix_fadvise(int fd, off_t base, off_t len, int advice)
 {
 #if defined(SYSCALL_FADVISE_6_ARG)
-	/* Some archs, at least arm and powerpc, have the syscall
+*/	/* Some archs, at least arm and powerpc, have the syscall
 	 * arguments reordered to avoid needing 7 argument registers
 	 * due to 64-bit argument alignment. */
-	return -__syscall(SYS_fadvise, fd, advice,
+/*	return -__syscall(SYS_fadvise, fd, advice,
 		__SYSCALL_LL_E(base), __SYSCALL_LL_E(len));
 #else
 	return -__syscall(SYS_fadvise, fd, __SYSCALL_LL_O(base),
@@ -17,3 +19,4 @@ int posix_fadvise(int fd, off_t base, off_t len, int advice)
 }
 
 LFS64(posix_fadvise);
+*/
diff --git a/src/fcntl/posix_fallocate.c b/src/fcntl/posix_fallocate.c
index 91d8063c..88d12929 100644
--- a/src/fcntl/posix_fallocate.c
+++ b/src/fcntl/posix_fallocate.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <fcntl.h>
 #include "syscall.h"
 #include "libc.h"
@@ -9,3 +11,4 @@ int posix_fallocate(int fd, off_t base, off_t len)
 }
 
 LFS64(posix_fallocate);
+*/
diff --git a/src/fenv/i386-myunix b/src/fenv/i386-myunix
new file mode 120000
index 00000000..fd32fa4e
--- /dev/null
+++ b/src/fenv/i386-myunix
@@ -0,0 +1 @@
+i386
\ No newline at end of file
diff --git a/src/fenv/i386/fenv.s b/src/fenv/i386/fenv.s
index a189ca2e..7c7904d5 100644
--- a/src/fenv/i386/fenv.s
+++ b/src/fenv/i386/fenv.s
@@ -17,7 +17,7 @@ feclearexcept:
 	jz 1f
 	fnclex
 1:	push %edx
-	stmxcsr (%esp)
+	# stmxcsr (%esp)
 	pop %edx
 	and $0x3f,%eax
 	or %eax,%edx
diff --git a/src/internal/i386-myunix/syscall.s b/src/internal/i386-myunix/syscall.s
new file mode 100644
index 00000000..c731a3d4
--- /dev/null
+++ b/src/internal/i386-myunix/syscall.s
@@ -0,0 +1,19 @@
+.global __syscall
+.hidden __syscall
+.type __syscall,@function
+__syscall:
+	lea 24(%esp),%eax
+	push %esi
+	push %edi
+	push %eax
+	mov 16(%esp),%eax
+	mov 20(%esp),%edx
+	mov 24(%esp),%ecx
+	mov 28(%esp),%edi
+	mov 32(%esp),%esi
+	call __vsyscall6
+	pop %edi
+	pop %edi
+	pop %esi
+	ret
+
diff --git a/src/internal/i386/syscall.s b/src/internal/i386/syscall.s
index 0ebf2218..612427cd 100644
--- a/src/internal/i386/syscall.s
+++ b/src/internal/i386/syscall.s
@@ -24,7 +24,7 @@ __vsyscall:
 	ret
 
 1:	mov (%esp),%eax
-	add $[__sysinfo-2b],%eax
+	add $(__sysinfo-2b),%eax
 	mov (%eax),%eax
 	test %eax,%eax
 	jz 1f
diff --git a/src/internal/libc.h b/src/internal/libc.h
index 5e145183..3c13eefb 100644
--- a/src/internal/libc.h
+++ b/src/internal/libc.h
@@ -51,8 +51,13 @@ void __lock(volatile int *) ATTR_LIBC_VISIBILITY;
 void __unlock(volatile int *) ATTR_LIBC_VISIBILITY;
 int __lockfile(FILE *) ATTR_LIBC_VISIBILITY;
 void __unlockfile(FILE *) ATTR_LIBC_VISIBILITY;
+/*
 #define LOCK(x) __lock(x)
 #define UNLOCK(x) __unlock(x)
+*/
+//#warning locking not working
+#define LOCK(x)
+#define UNLOCK(x)
 
 void __synccall(void (*)(void *), void *);
 int __setxid(int, int, int, int);
diff --git a/src/internal/libm.h b/src/internal/libm.h
index df864111..dc755856 100644
--- a/src/internal/libm.h
+++ b/src/internal/libm.h
@@ -16,7 +16,7 @@
 #include <stdint.h>
 #include <float.h>
 #include <math.h>
-#include <complex.h>
+//#include <complex.h>
 #include <endian.h>
 
 #if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
@@ -147,12 +147,12 @@ do {                                              \
 #undef CMPLXF
 #undef CMPLXL
 
-#define __CMPLX(x, y, t) \
+//#define __CMPLX(x, y, t) \
 	((union { _Complex t __z; t __xy[2]; }){.__xy = {(x),(y)}}.__z)
 
-#define CMPLX(x, y) __CMPLX(x, y, double)
-#define CMPLXF(x, y) __CMPLX(x, y, float)
-#define CMPLXL(x, y) __CMPLX(x, y, long double)
+//#define CMPLX(x, y) __CMPLX(x, y, double)
+//#define CMPLXF(x, y) __CMPLX(x, y, float)
+//#define CMPLXL(x, y) __CMPLX(x, y, long double)
 
 /* fdlibm kernel functions */
 
@@ -163,14 +163,14 @@ double __sin(double,double,int);
 double __cos(double,double);
 double __tan(double,double,int);
 double __expo2(double);
-double complex __ldexp_cexp(double complex,int);
+//double complex __ldexp_cexp(double complex,int);
 
 int    __rem_pio2f(float,double*);
 float  __sindf(double);
 float  __cosdf(double);
 float  __tandf(double,int);
 float  __expo2f(float);
-float complex __ldexp_cexpf(float complex,int);
+//float complex __ldexp_cexpf(float complex,int);
 
 int __rem_pio2l(long double, long double *);
 long double __sinl(long double, long double, int);
diff --git a/src/internal/locale_impl.h b/src/internal/locale_impl.h
index d5a3cc94..6c6717a6 100644
--- a/src/internal/locale_impl.h
+++ b/src/internal/locale_impl.h
@@ -24,14 +24,13 @@ const char *__mo_lookup(const void *, size_t, const char *);
 const char *__lctrans(const char *, const struct __locale_map *);
 const char *__lctrans_cur(const char *);
 
-#define LCTRANS(msg, lc, loc) __lctrans(msg, (loc)->cat[(lc)])
-#define LCTRANS_CUR(msg) __lctrans_cur(msg)
+#define LCTRANS(msg, lc, loc) ((msg))
+#define LCTRANS_CUR(msg) ((msg))
 
 #define C_LOCALE ((locale_t)&__c_locale)
 #define UTF8_LOCALE ((locale_t)&__c_dot_utf8_locale)
 
-#define CURRENT_LOCALE (__pthread_self()->locale)
-
+#define CURRENT_LOCALE ((locale_t)__c_locale)
 #define CURRENT_UTF8 (!!__pthread_self()->locale->cat[LC_CTYPE])
 
 #undef MB_CUR_MAX
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index f6a4f2c2..5213945f 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -137,6 +137,7 @@ void __vm_unlock(void);
 int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
 int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
 void __wait(volatile int *, volatile int *, int, int);
+/*
 static inline void __wake(volatile void *addr, int cnt, int priv)
 {
 	if (priv) priv = FUTEX_PRIVATE;
@@ -150,7 +151,7 @@ static inline void __futexwait(volatile void *addr, int val, int priv)
 	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val) != -ENOSYS ||
 	__syscall(SYS_futex, addr, FUTEX_WAIT, val);
 }
-
+*/
 void __acquire_ptc(void);
 void __release_ptc(void);
 void __inhibit_ptc(void);
diff --git a/src/internal/syscall.h b/src/internal/syscall.h
index 6d378a81..3c011239 100644
--- a/src/internal/syscall.h
+++ b/src/internal/syscall.h
@@ -56,6 +56,8 @@ long __syscall_ret(unsigned long), __syscall(syscall_arg_t, ...),
 #define socketcall __socketcall
 #define socketcall_cp __socketcall_cp
 
+// FIXME:
+#if 0
 #define __syscall_cp0(n) (__syscall_cp)(n,0,0,0,0,0,0)
 #define __syscall_cp1(n,a) (__syscall_cp)(n,__scc(a),0,0,0,0,0)
 #define __syscall_cp2(n,a,b) (__syscall_cp)(n,__scc(a),__scc(b),0,0,0,0)
@@ -63,6 +65,15 @@ long __syscall_ret(unsigned long), __syscall(syscall_arg_t, ...),
 #define __syscall_cp4(n,a,b,c,d) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),0,0)
 #define __syscall_cp5(n,a,b,c,d,e) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),0)
 #define __syscall_cp6(n,a,b,c,d,e,f) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
+#else
+#define __syscall_cp0(n) __syscall0(n)
+#define __syscall_cp1(n,a) __syscall1(n,__scc(a))
+#define __syscall_cp2(n,a,b) __syscall2(n,__scc(a),__scc(b))
+#define __syscall_cp3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))
+#define __syscall_cp4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))
+#define __syscall_cp5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))
+#define __syscall_cp6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
+#endif
 
 #define __syscall_cp(...) __SYSCALL_DISP(__syscall_cp,__VA_ARGS__)
 #define syscall_cp(...) __syscall_ret(__syscall_cp(__VA_ARGS__))
@@ -234,8 +245,10 @@ long __syscall_ret(unsigned long), __syscall(syscall_arg_t, ...),
 #else
 #define __sys_open2(x,pn,fl) __syscall3(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE)
 #define __sys_open3(x,pn,fl,mo) __syscall4(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE, mo)
+/*
 #define __sys_open_cp2(x,pn,fl) __syscall_cp3(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE)
 #define __sys_open_cp3(x,pn,fl,mo) __syscall_cp4(SYS_openat, AT_FDCWD, pn, (fl)|O_LARGEFILE, mo)
+*/
 #endif
 
 #define __sys_open(...) __SYSCALL_DISP(__sys_open,,__VA_ARGS__)
diff --git a/src/ldso/i386-myunix/dlsym.s b/src/ldso/i386-myunix/dlsym.s
new file mode 100644
index 00000000..097e30ce
--- /dev/null
+++ b/src/ldso/i386-myunix/dlsym.s
@@ -0,0 +1,11 @@
+.text
+.global dlsym
+.hidden __dlsym
+.type dlsym,@function
+dlsym:
+	push (%esp)
+	push 12(%esp)
+	push 12(%esp)
+	call __dlsym
+	add $12,%esp
+	ret
diff --git a/src/ldso/i386-myunix/tlsdesc.s b/src/ldso/i386-myunix/tlsdesc.s
new file mode 100644
index 00000000..4a553bce
--- /dev/null
+++ b/src/ldso/i386-myunix/tlsdesc.s
@@ -0,0 +1,31 @@
+.text
+.global __tlsdesc_static
+.hidden __tlsdesc_static
+.type __tlsdesc_static,@function
+__tlsdesc_static:
+	mov 4(%eax),%eax
+	ret
+
+.hidden __tls_get_new
+
+.global __tlsdesc_dynamic
+.hidden __tlsdesc_dynamic
+.type __tlsdesc_dynamic,@function
+__tlsdesc_dynamic:
+	mov 4(%eax),%eax
+	push %edx
+	mov %gs:4,%edx
+	push %ecx
+	mov (%eax),%ecx
+	cmp %ecx,(%edx)
+	jc 1f
+	mov 4(%eax),%eax
+	add (%edx,%ecx,4),%eax
+2:	pop %ecx
+	sub %gs:0,%eax
+	pop %edx
+	ret
+1:	push %eax
+	call __tls_get_new
+	pop %ecx
+	jmp 2b
diff --git a/src/malloc/__brk.c b/src/malloc/__brk.c
index 4c9119b4..d0764b8a 100644
--- a/src/malloc/__brk.c
+++ b/src/malloc/__brk.c
@@ -1,3 +1,4 @@
+/*
 #include <stdint.h>
 #include "syscall.h"
 
@@ -5,3 +6,4 @@ uintptr_t __brk(uintptr_t newbrk)
 {
 	return __syscall(SYS_brk, newbrk);
 }
+*/
diff --git a/src/malloc/expand_heap.c b/src/malloc/expand_heap.c
index d8c0be74..f93979e0 100644
--- a/src/malloc/expand_heap.c
+++ b/src/malloc/expand_heap.c
@@ -39,7 +39,6 @@ void *__mmap(void *, size_t, int, int, int, off_t);
 
 void *__expand_heap(size_t *pn)
 {
-	static uintptr_t brk;
 	static unsigned mmap_step;
 	size_t n = *pn;
 
@@ -49,22 +48,12 @@ void *__expand_heap(size_t *pn)
 	}
 	n += -n & PAGE_SIZE-1;
 
-	if (!brk) {
-		brk = __syscall(SYS_brk, 0);
-		brk += -brk & PAGE_SIZE-1;
-	}
-
-	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
-	    && __syscall(SYS_brk, brk+n)==brk+n) {
-		*pn = n;
-		brk += n;
-		return (void *)(brk-n);
-	}
-
 	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
 	if (n < min) n = min;
 	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
 		MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+//	void *area = (void *)syscall(SYS_mmap_anon, 0, n, PROT_READ|PROT_WRITE);
+//	printf("area: %x\n", (uintptr_t)area);
 	if (area == MAP_FAILED) return 0;
 	*pn = n;
 	mmap_step++;
diff --git a/src/malloc/malloc.c b/src/malloc/malloc.c
index 9e05e1d6..a0e140af 100644
--- a/src/malloc/malloc.c
+++ b/src/malloc/malloc.c
@@ -60,16 +60,18 @@ static struct {
 
 static inline void lock(volatile int *lk)
 {
-	if (libc.threads_minus_1)
-		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+// FIXME: implement
+//	if (libc.threads_minus_1)
+//		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
 }
 
 static inline void unlock(volatile int *lk)
 {
-	if (lk[0]) {
-		a_store(lk, 0);
-		if (lk[1]) __wake(lk, 1, 1);
-	}
+// FIXME: implement
+//	if (lk[0]) {
+//		a_store(lk, 0);
+//		if (lk[1]) __wake(lk, 1, 1);
+//	}
 }
 
 static inline void lock_bin(int i)
diff --git a/src/math/i386-myunix b/src/math/i386-myunix
new file mode 120000
index 00000000..fd32fa4e
--- /dev/null
+++ b/src/math/i386-myunix
@@ -0,0 +1 @@
+i386
\ No newline at end of file
diff --git a/src/misc/getpriority.c b/src/misc/getpriority.c
index 5c0b1682..6d6047ed 100644
--- a/src/misc/getpriority.c
+++ b/src/misc/getpriority.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/resource.h>
 #include "syscall.h"
 
@@ -7,3 +9,4 @@ int getpriority(int which, id_t who)
 	if (ret < 0) return ret;
 	return 20-ret;
 }
+*/
diff --git a/src/misc/getresgid.c b/src/misc/getresgid.c
index d00d9a99..e4e423f7 100644
--- a/src/misc/getresgid.c
+++ b/src/misc/getresgid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
@@ -6,3 +8,4 @@ int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)
 {
 	return syscall(SYS_getresgid, rgid, egid, sgid);
 }
+*/
diff --git a/src/misc/getresuid.c b/src/misc/getresuid.c
index d75d5d40..f89bee9e 100644
--- a/src/misc/getresuid.c
+++ b/src/misc/getresuid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
@@ -6,3 +8,4 @@ int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)
 {
 	return syscall(SYS_getresuid, ruid, euid, suid);
 }
+*/
diff --git a/src/misc/getrlimit.c b/src/misc/getrlimit.c
index b073677f..a5a8378b 100644
--- a/src/misc/getrlimit.c
+++ b/src/misc/getrlimit.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/resource.h>
 #include <errno.h>
 #include "syscall.h"
@@ -25,3 +27,4 @@ int getrlimit(int resource, struct rlimit *rlim)
 }
 
 LFS64(getrlimit);
+*/
diff --git a/src/misc/getrusage.c b/src/misc/getrusage.c
index 0aaf0ac7..899f011e 100644
--- a/src/misc/getrusage.c
+++ b/src/misc/getrusage.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/resource.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int getrusage(int who, struct rusage *ru)
 {
 	return syscall(SYS_getrusage, who, ru);
 }
+*/
diff --git a/src/misc/ioctl.c b/src/misc/ioctl.c
index 5a41f0e8..46838d03 100644
--- a/src/misc/ioctl.c
+++ b/src/misc/ioctl.c
@@ -4,10 +4,14 @@
 
 int ioctl(int fd, int req, ...)
 {
+/*
+// TODO: implement
 	void *arg;
 	va_list ap;
 	va_start(ap, req);
 	arg = va_arg(ap, void *);
 	va_end(ap);
 	return syscall(SYS_ioctl, fd, req, arg);
+*/
+	return -1;
 }
diff --git a/src/misc/pty.c b/src/misc/pty.c
index b395d2c0..dad5d098 100644
--- a/src/misc/pty.c
+++ b/src/misc/pty.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <stdlib.h>
 #include <sys/ioctl.h>
 #include <stdio.h>
@@ -32,3 +34,4 @@ int __ptsname_r(int fd, char *buf, size_t len)
 }
 
 weak_alias(__ptsname_r, ptsname_r);
+*/
diff --git a/src/misc/setdomainname.c b/src/misc/setdomainname.c
index 22d3f746..b198f294 100644
--- a/src/misc/setdomainname.c
+++ b/src/misc/setdomainname.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
@@ -6,3 +8,4 @@ int setdomainname(const char *name, size_t len)
 {
 	return syscall(SYS_setdomainname, name, len);
 }
+*/
diff --git a/src/misc/setpriority.c b/src/misc/setpriority.c
index 3098cdf4..58f5ba9d 100644
--- a/src/misc/setpriority.c
+++ b/src/misc/setpriority.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/resource.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int setpriority(int which, id_t who, int prio)
 {
 	return syscall(SYS_setpriority, which, who, prio);
 }
+*/
diff --git a/src/misc/setrlimit.c b/src/misc/setrlimit.c
index 7130d719..2b3ad4fb 100644
--- a/src/misc/setrlimit.c
+++ b/src/misc/setrlimit.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/resource.h>
 #include <errno.h>
 #include "syscall.h"
@@ -48,3 +50,4 @@ int setrlimit(int resource, const struct rlimit *rlim)
 }
 
 LFS64(setrlimit);
+*/
diff --git a/src/misc/uname.c b/src/misc/uname.c
index 55ea3420..80ee8ae7 100644
--- a/src/misc/uname.c
+++ b/src/misc/uname.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/utsname.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int uname(struct utsname *uts)
 {
 	return syscall(SYS_uname, uts);
 }
+*/
diff --git a/src/mman/madvise.c b/src/mman/madvise.c
index f80926be..13d48f44 100644
--- a/src/mman/madvise.c
+++ b/src/mman/madvise.c
@@ -1,10 +1,13 @@
+// TODO: give me a good reason to implement it
 #include <sys/mman.h>
 #include "syscall.h"
 #include "libc.h"
 
 int __madvise(void *addr, size_t len, int advice)
 {
-	return syscall(SYS_madvise, addr, len, advice);
+//	assert(0);
+	return -1;
+//	return syscall(SYS_madvise, addr, len, advice);
 }
 
 weak_alias(__madvise, madvise);
diff --git a/src/mman/mincore.c b/src/mman/mincore.c
index 4bb19f85..55462d7d 100644
--- a/src/mman/mincore.c
+++ b/src/mman/mincore.c
@@ -1,3 +1,5 @@
+/*
+// TODO: midly usefull
 #define _GNU_SOURCE
 #include <sys/mman.h>
 #include "syscall.h"
@@ -6,3 +8,4 @@ int mincore (void *addr, size_t len, unsigned char *vec)
 {
 	return syscall(SYS_mincore, addr, len, vec);
 }
+*/
diff --git a/src/mman/mlock.c b/src/mman/mlock.c
index e683a44a..16b989e2 100644
--- a/src/mman/mlock.c
+++ b/src/mman/mlock.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int mlock(const void *addr, size_t len)
 {
 	return syscall(SYS_mlock, addr, len);
 }
+*/
diff --git a/src/mman/mlockall.c b/src/mman/mlockall.c
index 0ba4e662..b82f097c 100644
--- a/src/mman/mlockall.c
+++ b/src/mman/mlockall.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int mlockall(int flags)
 {
 	return syscall(SYS_mlockall, flags);
 }
+*/
diff --git a/src/mman/mmap.c b/src/mman/mmap.c
index 15924033..d420025f 100644
--- a/src/mman/mmap.c
+++ b/src/mman/mmap.c
@@ -1,3 +1,4 @@
+// TODO: implement
 #include <unistd.h>
 #include <sys/mman.h>
 #include <errno.h>
@@ -28,8 +29,11 @@ void *__mmap(void *start, size_t len, int prot, int flags, int fd, off_t off)
 	}
 #ifdef SYS_mmap2
 	ret = __syscall(SYS_mmap2, start, len, prot, flags, fd, off/UNIT);
-#else
+#elif defined(SYS_mmap)
 	ret = __syscall(SYS_mmap, start, len, prot, flags, fd, off);
+#else
+//	ret = __syscall(SYS_mmap_anon, start, len, prot, flags, fd, off/UNIT);
+	ret = __syscall(SYS_mmap_anon, start, len, prot);
 #endif
 	/* Fixup incorrect EPERM from kernel. */
 	if (ret == -EPERM && !start && (flags&MAP_ANON) && !(flags&MAP_FIXED))
diff --git a/src/mman/mprotect.c b/src/mman/mprotect.c
index 535787b9..bf45390e 100644
--- a/src/mman/mprotect.c
+++ b/src/mman/mprotect.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "libc.h"
 #include "syscall.h"
@@ -11,3 +13,4 @@ int __mprotect(void *addr, size_t len, int prot)
 }
 
 weak_alias(__mprotect, mprotect);
+*/
diff --git a/src/mman/mremap.c b/src/mman/mremap.c
index ce4e8ea1..d310262a 100644
--- a/src/mman/mremap.c
+++ b/src/mman/mremap.c
@@ -1,3 +1,4 @@
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include <sys/mman.h>
@@ -12,7 +13,8 @@ weak_alias(dummy, __vm_wait);
 
 void *__mremap(void *old_addr, size_t old_len, size_t new_len, int flags, ...)
 {
-	va_list ap;
+	return -1;
+/*	va_list ap;
 	void *new_addr = 0;
 
 	if (new_len >= PTRDIFF_MAX) {
@@ -28,6 +30,8 @@ void *__mremap(void *old_addr, size_t old_len, size_t new_len, int flags, ...)
 	}
 
 	return (void *)syscall(SYS_mremap, old_addr, old_len, new_len, flags, new_addr);
+*/
 }
 
 weak_alias(__mremap, mremap);
+
diff --git a/src/mman/msync.c b/src/mman/msync.c
index fcd8cdf9..6555a8f5 100644
--- a/src/mman/msync.c
+++ b/src/mman/msync.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int msync(void *start, size_t len, int flags)
 {
 	return syscall_cp(SYS_msync, start, len, flags);
 }
+*/
diff --git a/src/mman/munlock.c b/src/mman/munlock.c
index 2cccef0c..b57f4447 100644
--- a/src/mman/munlock.c
+++ b/src/mman/munlock.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int munlock(const void *addr, size_t len)
 {
 	return syscall(SYS_munlock, addr, len);
 }
+*/
diff --git a/src/mman/munlockall.c b/src/mman/munlockall.c
index 6e9d39d6..33e37d77 100644
--- a/src/mman/munlockall.c
+++ b/src/mman/munlockall.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int munlockall(void)
 {
 	return syscall(SYS_munlockall);
 }
+*/
diff --git a/src/mman/munmap.c b/src/mman/munmap.c
index 3f711ee5..2b475e42 100644
--- a/src/mman/munmap.c
+++ b/src/mman/munmap.c
@@ -1,3 +1,4 @@
+// TODO: implement
 #include <sys/mman.h>
 #include "syscall.h"
 #include "libc.h"
@@ -12,3 +13,4 @@ int __munmap(void *start, size_t len)
 }
 
 weak_alias(__munmap, munmap);
+
diff --git a/src/mman/posix_madvise.c b/src/mman/posix_madvise.c
index e5e5acb8..a6ae12e1 100644
--- a/src/mman/posix_madvise.c
+++ b/src/mman/posix_madvise.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <sys/mman.h>
 #include "syscall.h"
@@ -7,3 +9,4 @@ int posix_madvise(void *addr, size_t len, int advice)
 	if (advice == MADV_DONTNEED) return 0;
 	return -__syscall(SYS_madvise, addr, len, advice);
 }
+*/
diff --git a/src/myunix/clone.c b/src/myunix/clone.c
new file mode 100644
index 00000000..b9e55945
--- /dev/null
+++ b/src/myunix/clone.c
@@ -0,0 +1,19 @@
+#include <stdarg.h>
+#include <unistd.h>
+#include "pthread_impl.h"
+#include "syscall.h"
+
+int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
+{
+	va_list ap;
+	pid_t *ptid, *ctid;
+	void  *tls;
+
+	va_start(ap, arg);
+	ptid = va_arg(ap, pid_t *);
+	tls  = va_arg(ap, void *);
+	ctid = va_arg(ap, pid_t *);
+	va_end(ap);
+
+	return __syscall_ret(__clone(func, stack, flags, arg, ptid, tls, ctid));
+}
diff --git a/src/process/fork.c b/src/process/fork.c
index da074ae9..54e6946d 100644
--- a/src/process/fork.c
+++ b/src/process/fork.c
@@ -16,20 +16,11 @@ pid_t fork(void)
 	pid_t ret;
 	sigset_t set;
 	__fork_handler(-1);
-	__block_all_sigs(&set);
-#ifdef SYS_fork
-	ret = __syscall(SYS_fork);
-#else
 	ret = __syscall(SYS_clone, SIGCHLD, 0);
-#endif
+
 	if (!ret) {
-		pthread_t self = __pthread_self();
-		self->tid = __syscall(SYS_gettid);
-		self->robust_list.off = 0;
-		self->robust_list.pending = 0;
 		libc.threads_minus_1 = 0;
 	}
-	__restore_sigs(&set);
 	__fork_handler(!ret);
 	return __syscall_ret(ret);
 }
diff --git a/src/process/i386-myunix b/src/process/i386-myunix
new file mode 120000
index 00000000..fd32fa4e
--- /dev/null
+++ b/src/process/i386-myunix
@@ -0,0 +1 @@
+i386
\ No newline at end of file
diff --git a/src/process/posix_spawn.c b/src/process/posix_spawn.c
index 93fb1555..b72ab3ef 100644
--- a/src/process/posix_spawn.c
+++ b/src/process/posix_spawn.c
@@ -49,7 +49,6 @@ static int child(void *args_vp)
 	 * memory, with unpredictable and dangerous results. To
 	 * reduce overhead, sigaction has tracked for us which signals
 	 * potentially have a signal handler. */
-	__get_handler_set(&hset);
 	for (i=1; i<_NSIG; i++) {
 		if ((attr->__flags & POSIX_SPAWN_SETSIGDEF)
 		     && sigismember(&attr->__def, i)) {
@@ -69,19 +68,15 @@ static int child(void *args_vp)
 	}
 
 	if (attr->__flags & POSIX_SPAWN_SETSID)
-		if ((ret=__syscall(SYS_setsid)) < 0)
 			goto fail;
 
 	if (attr->__flags & POSIX_SPAWN_SETPGROUP)
-		if ((ret=__syscall(SYS_setpgid, 0, attr->__pgrp)))
 			goto fail;
 
 	/* Use syscalls directly because the library functions attempt
 	 * to do a multi-threaded synchronized id-change, which would
 	 * trash the parent's state. */
 	if (attr->__flags & POSIX_SPAWN_RESETIDS)
-		if ((ret=__syscall(SYS_setgid, __syscall(SYS_getgid))) ||
-		    (ret=__syscall(SYS_setuid, __syscall(SYS_getuid))) )
 			goto fail;
 
 	if (fa && fa->__actions) {
@@ -109,10 +104,6 @@ static int child(void *args_vp)
 					if ((ret=__sys_dup2(fd, op->fd))<0)
 						goto fail;
 				} else {
-					ret = __syscall(SYS_fcntl, fd, F_GETFD);
-					ret = __syscall(SYS_fcntl, fd, F_SETFD,
-					                ret & ~FD_CLOEXEC);
-					if (ret<0)
 						goto fail;
 				}
 				break;
@@ -133,10 +124,6 @@ static int child(void *args_vp)
 	 * to a different fd. We don't use F_DUPFD_CLOEXEC above because
 	 * it would fail on older kernels and atomicity is not needed --
 	 * in this process there are no threads or signal handlers. */
-	__syscall(SYS_fcntl, p, F_SETFD, FD_CLOEXEC);
-
-	pthread_sigmask(SIG_SETMASK, (attr->__flags & POSIX_SPAWN_SETSIGMASK)
-		? &attr->__mask : &args->oldmask, 0);
 
 	args->exec(args->path, args->argv, args->envp);
 	ret = -errno;
@@ -148,7 +135,6 @@ fail:
 	_exit(127);
 }
 
-
 int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 	int (*exec)(const char *, char *const *, char *const *),
 	const posix_spawn_file_actions_t *fa,
@@ -160,10 +146,6 @@ int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 	int ec=0, cs;
 	struct args args;
 
-	if (pipe2(args.p, O_CLOEXEC))
-		return errno;
-
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 
 	args.path = path;
 	args.exec = exec;
@@ -171,7 +153,6 @@ int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 	args.attr = attr ? attr : &(const posix_spawnattr_t){0};
 	args.argv = argv;
 	args.envp = envp;
-	pthread_sigmask(SIG_BLOCK, SIGALL_SET, &args.oldmask);
 
 	pid = __clone(child, stack+sizeof stack,
 		CLONE_VM|CLONE_VFORK|SIGCHLD, &args);
@@ -188,8 +169,6 @@ int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 
 	if (!ec && res) *res = pid;
 
-	pthread_sigmask(SIG_SETMASK, &args.oldmask, 0);
-	pthread_setcancelstate(cs, 0);
 
 	return ec;
 }
diff --git a/src/process/system.c b/src/process/system.c
index 8cbdda06..2608c4e8 100644
--- a/src/process/system.c
+++ b/src/process/system.c
@@ -17,7 +17,6 @@ int system(const char *cmd)
 	int status = 0x7f00, ret;
 	posix_spawnattr_t attr;
 
-	pthread_testcancel();
 
 	if (!cmd) return 1;
 
diff --git a/src/process/vfork.c b/src/process/vfork.c
index ac954651..e59d28c5 100644
--- a/src/process/vfork.c
+++ b/src/process/vfork.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include <signal.h>
@@ -6,7 +8,7 @@
 
 pid_t __vfork(void)
 {
-	/* vfork syscall cannot be made from C code */
+*/	/* vfork syscall cannot be made from C code *//*
 #ifdef SYS_fork
 	return syscall(SYS_fork);
 #else
@@ -15,3 +17,4 @@ pid_t __vfork(void)
 }
 
 weak_alias(__vfork, vfork);
+*/
diff --git a/src/process/waitid.c b/src/process/waitid.c
index c67feac3..cdd460e8 100644
--- a/src/process/waitid.c
+++ b/src/process/waitid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/wait.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int waitid(idtype_t type, id_t id, siginfo_t *info, int options)
 {
 	return syscall_cp(SYS_waitid, type, id, info, options, 0);
 }
+*/
diff --git a/src/process/waitpid.c b/src/process/waitpid.c
index f75e31ef..f5948302 100644
--- a/src/process/waitpid.c
+++ b/src/process/waitpid.c
@@ -4,5 +4,5 @@
 
 pid_t waitpid(pid_t pid, int *status, int options)
 {
-	return syscall_cp(SYS_wait4, pid, status, options, 0);
+	return syscall_cp(SYS_waitpid, pid, status, options);
 }
diff --git a/src/regex/glob.c b/src/regex/glob.c
index 85671985..d24ccce7 100644
--- a/src/regex/glob.c
+++ b/src/regex/glob.c
@@ -93,7 +93,7 @@ static int match_in_dir(const char *d, const char *p, int flags, int (*errfunc)(
 		return error;
 	}
 	while (!(error = readdir_r(dir, &de_buf, &de)) && de) {
-		char namebuf[l+de->d_reclen+2], *name = namebuf;
+		char namebuf[l + 256 + 2], *name = namebuf;
 		if (!literal && fnmatch(p, de->d_name, fnm_flags))
 			continue;
 		if (literal && strcmp(p, de->d_name))
@@ -129,7 +129,7 @@ static int match_in_dir(const char *d, const char *p, int flags, int (*errfunc)(
 					mark = S_ISDIR(st.st_mode);
 				}
 			}
-			if (append(tail, name, l+de->d_reclen+1, mark)) {
+			if (append(tail, name, l + 256 + 2, mark)) {
 				closedir(dir);
 				return GLOB_NOSPACE;
 			}
diff --git a/src/sched/affinity.c b/src/sched/affinity.c
deleted file mode 100644
index 948ece41..00000000
--- a/src/sched/affinity.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#define _GNU_SOURCE
-#include <sched.h>
-#include <string.h>
-#include "pthread_impl.h"
-#include "syscall.h"
-
-int sched_setaffinity(pid_t tid, size_t size, const cpu_set_t *set)
-{
-	return syscall(SYS_sched_setaffinity, tid, size, set);
-}
-
-int pthread_setaffinity_np(pthread_t td, size_t size, const cpu_set_t *set)
-{
-	return -__syscall(SYS_sched_setaffinity, td->tid, size, set);
-}
-
-static int do_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
-{
-	long ret = __syscall(SYS_sched_getaffinity, tid, size, set);
-	if (ret < 0) return ret;
-	if (ret < size) memset((char *)set+ret, 0, size-ret);
-	return 0;
-}
-
-int sched_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
-{
-	return __syscall_ret(do_getaffinity(tid, size, set));
-}
-
-int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
-{
-	return -do_getaffinity(td->tid, size, set);
-}
diff --git a/src/sched/sched_cpucount.c b/src/sched/sched_cpucount.c
deleted file mode 100644
index 94aa259e..00000000
--- a/src/sched/sched_cpucount.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#define _GNU_SOURCE
-#include <sched.h>
-
-int __sched_cpucount(size_t size, const cpu_set_t *set)
-{
-	size_t i, j, cnt=0;
-	const unsigned char *p = (const void *)set;
-	for (i=0; i<size; i++) for (j=0; j<8; j++)
-		if (p[i] & (1<<j)) cnt++;
-	return cnt;
-}
diff --git a/src/sched/sched_get_priority_max.c b/src/sched/sched_get_priority_max.c
deleted file mode 100644
index 30ae5100..00000000
--- a/src/sched/sched_get_priority_max.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <sched.h>
-#include "syscall.h"
-
-int sched_get_priority_max(int policy)
-{
-	return syscall(SYS_sched_get_priority_max, policy);
-}
-
-int sched_get_priority_min(int policy)
-{
-	return syscall(SYS_sched_get_priority_min, policy);
-}
diff --git a/src/sched/sched_getcpu.c b/src/sched/sched_getcpu.c
deleted file mode 100644
index e08cfdf1..00000000
--- a/src/sched/sched_getcpu.c
+++ /dev/null
@@ -1,44 +0,0 @@
-#define _GNU_SOURCE
-#include <errno.h>
-#include <sched.h>
-#include "syscall.h"
-#include "atomic.h"
-
-#ifdef VDSO_GETCPU_SYM
-
-void *__vdsosym(const char *, const char *);
-
-static void *volatile vdso_func;
-
-typedef long (*getcpu_f)(unsigned *, unsigned *, void *);
-
-static long getcpu_init(unsigned *cpu, unsigned *node, void *unused)
-{
-	void *p = __vdsosym(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
-	getcpu_f f = (getcpu_f)p;
-	a_cas_p(&vdso_func, (void *)getcpu_init, p);
-	return f ? f(cpu, node, unused) : -ENOSYS;
-}
-
-static void *volatile vdso_func = (void *)getcpu_init;
-
-#endif
-
-int sched_getcpu(void)
-{
-	int r;
-	unsigned cpu;
-
-#ifdef VDSO_GETCPU_SYM
-	getcpu_f f = (getcpu_f)vdso_func;
-	if (f) {
-		r = f(&cpu, 0, 0);
-		if (!r) return cpu;
-		if (r != -ENOSYS) return __syscall_ret(r);
-	}
-#endif
-
-	r = __syscall(SYS_getcpu, &cpu, 0, 0);
-	if (!r) return cpu;
-	return __syscall_ret(r);
-}
diff --git a/src/sched/sched_getparam.c b/src/sched/sched_getparam.c
deleted file mode 100644
index 76f10e49..00000000
--- a/src/sched/sched_getparam.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_getparam(pid_t pid, struct sched_param *param)
-{
-	return __syscall_ret(-ENOSYS);
-}
diff --git a/src/sched/sched_getscheduler.c b/src/sched/sched_getscheduler.c
deleted file mode 100644
index 394e508b..00000000
--- a/src/sched/sched_getscheduler.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_getscheduler(pid_t pid)
-{
-	return __syscall_ret(-ENOSYS);
-}
diff --git a/src/sched/sched_rr_get_interval.c b/src/sched/sched_rr_get_interval.c
deleted file mode 100644
index 4b01028f..00000000
--- a/src/sched/sched_rr_get_interval.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <sched.h>
-#include "syscall.h"
-
-int sched_rr_get_interval(pid_t pid, struct timespec *ts)
-{
-	return syscall(SYS_sched_rr_get_interval, pid, ts);
-}
diff --git a/src/sched/sched_setparam.c b/src/sched/sched_setparam.c
deleted file mode 100644
index 18623ee4..00000000
--- a/src/sched/sched_setparam.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_setparam(pid_t pid, const struct sched_param *param)
-{
-	return __syscall_ret(-ENOSYS);
-}
diff --git a/src/sched/sched_setscheduler.c b/src/sched/sched_setscheduler.c
deleted file mode 100644
index 4435f216..00000000
--- a/src/sched/sched_setscheduler.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_setscheduler(pid_t pid, int sched, const struct sched_param *param)
-{
-	return __syscall_ret(-ENOSYS);
-}
diff --git a/src/select/poll.c b/src/select/poll.c
index 9e0bcbd8..a822d994 100644
--- a/src/select/poll.c
+++ b/src/select/poll.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <poll.h>
 #include <time.h>
 #include <signal.h>
@@ -14,3 +16,4 @@ int poll(struct pollfd *fds, nfds_t n, int timeout)
 		.tv_nsec = timeout%1000*1000000 }) : 0, 0, _NSIG/8);
 #endif
 }
+*/
diff --git a/src/select/pselect.c b/src/select/pselect.c
index 4e2d7b07..c3c6ead3 100644
--- a/src/select/pselect.c
+++ b/src/select/pselect.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/select.h>
 #include <signal.h>
 #include <stdint.h>
@@ -11,3 +13,4 @@ int pselect(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restric
 	if (ts) ts_tmp = *ts;
 	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds, ts ? &ts_tmp : 0, data);
 }
+*/
diff --git a/src/select/select.c b/src/select/select.c
index 7b5f6dcf..02d22155 100644
--- a/src/select/select.c
+++ b/src/select/select.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/select.h>
 #include <signal.h>
 #include <stdint.h>
@@ -24,3 +26,4 @@ int select(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict
 	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds, tv ? &ts : 0, data);
 #endif
 }
+*/
diff --git a/src/setjmp/i386-myunix b/src/setjmp/i386-myunix
new file mode 120000
index 00000000..fd32fa4e
--- /dev/null
+++ b/src/setjmp/i386-myunix
@@ -0,0 +1 @@
+i386
\ No newline at end of file
diff --git a/src/signal/block.c b/src/signal/block.c
index d7f61001..6d1b8234 100644
--- a/src/signal/block.c
+++ b/src/signal/block.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include "pthread_impl.h"
 #include "syscall.h"
 #include <signal.h>
@@ -42,3 +44,4 @@ void __restore_sigs(void *set)
 {
 	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, set, 0, _NSIG/8);
 }
+*/
diff --git a/src/signal/getitimer.c b/src/signal/getitimer.c
index 8a8046a7..472f5a15 100644
--- a/src/signal/getitimer.c
+++ b/src/signal/getitimer.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/time.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int getitimer(int which, struct itimerval *old)
 {
 	return syscall(SYS_getitimer, which, old);
 }
+*/
diff --git a/src/signal/kill.c b/src/signal/kill.c
index 05805733..bb93908e 100644
--- a/src/signal/kill.c
+++ b/src/signal/kill.c
@@ -3,5 +3,9 @@
 
 int kill(pid_t pid, int sig)
 {
+/*
+// TODO: implement
 	return syscall(SYS_kill, pid, sig);
+*/
+	return -1;
 }
diff --git a/src/signal/raise.c b/src/signal/raise.c
index 717b1c91..489d97e5 100644
--- a/src/signal/raise.c
+++ b/src/signal/raise.c
@@ -5,6 +5,8 @@
 
 int raise(int sig)
 {
+/*
+// TODO: implement
 	int tid, ret;
 	sigset_t set;
 	__block_app_sigs(&set);
@@ -12,4 +14,6 @@ int raise(int sig)
 	ret = syscall(SYS_tkill, tid, sig);
 	__restore_sigs(&set);
 	return ret;
+*/
+	return -1;
 }
diff --git a/src/signal/setitimer.c b/src/signal/setitimer.c
index 21b1f45d..77785eb6 100644
--- a/src/signal/setitimer.c
+++ b/src/signal/setitimer.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/time.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int setitimer(int which, const struct itimerval *restrict new, struct itimerval
 {
 	return syscall(SYS_setitimer, which, new, old);
 }
+*/
diff --git a/src/signal/sigaction.c b/src/signal/sigaction.c
index 6eca06f1..a8be436f 100644
--- a/src/signal/sigaction.c
+++ b/src/signal/sigaction.c
@@ -6,6 +6,8 @@
 #include "libc.h"
 #include "ksigaction.h"
 
+/*
+// TODO: implement
 static int unmask_done;
 static unsigned long handler_set[_NSIG/(8*sizeof(long))];
 
@@ -13,16 +15,17 @@ void __get_handler_set(sigset_t *set)
 {
 	memcpy(set, handler_set, sizeof handler_set);
 }
-
+*/
 int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
+/*
 	struct k_sigaction ksa, ksa_old;
 	if (sa) {
 		if ((uintptr_t)sa->sa_handler > 1UL) {
 			a_or_l(handler_set+(sig-1)/(8*sizeof(long)),
 				1UL<<(sig-1)%(8*sizeof(long)));
 
-			/* If pthread_create has not yet been called,
+*/			/* If pthread_create has not yet been called,
 			 * implementation-internal signals might not
 			 * yet have been unblocked. They must be
 			 * unblocked before any signal handler is
@@ -30,7 +33,7 @@ int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigact
 			 * receive an illegal sigset_t (with them
 			 * blocked) as part of the ucontext_t passed
 			 * to the signal handler. */
-			if (!libc.threaded && !unmask_done) {
+/*			if (!libc.threaded && !unmask_done) {
 				__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
 					SIGPT_SET, 0, _NSIG/8);
 				unmask_done = 1;
@@ -48,6 +51,8 @@ int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigact
 		old->sa_flags = ksa_old.flags;
 		memcpy(&old->sa_mask, &ksa_old.mask, sizeof ksa_old.mask);
 	}
+*/
+
 	return 0;
 }
 
diff --git a/src/signal/sigaltstack.c b/src/signal/sigaltstack.c
index 62cb81ad..8ef9bbbd 100644
--- a/src/signal/sigaltstack.c
+++ b/src/signal/sigaltstack.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <signal.h>
 #include <errno.h>
 #include "syscall.h"
@@ -16,3 +18,4 @@ int sigaltstack(const stack_t *restrict ss, stack_t *restrict old)
 	}
 	return syscall(SYS_sigaltstack, ss, old);
 }
+*/
diff --git a/src/signal/sigpending.c b/src/signal/sigpending.c
index 3d193df8..69e987f2 100644
--- a/src/signal/sigpending.c
+++ b/src/signal/sigpending.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <signal.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int sigpending(sigset_t *set)
 {
 	return syscall(SYS_rt_sigpending, set, _NSIG/8);
 }
+*/
diff --git a/src/signal/sigprocmask.c b/src/signal/sigprocmask.c
index 297e20c6..89879417 100644
--- a/src/signal/sigprocmask.c
+++ b/src/signal/sigprocmask.c
@@ -3,8 +3,12 @@
 
 int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
 {
+	// TODO: implement
+/*
 	int r = pthread_sigmask(how, set, old);
 	if (!r) return r;
 	errno = r;
 	return -1;
+*/
+	return -1;
 }
diff --git a/src/signal/sigqueue.c b/src/signal/sigqueue.c
index b75f0c5c..c11ea007 100644
--- a/src/signal/sigqueue.c
+++ b/src/signal/sigqueue.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <signal.h>
 #include <string.h>
 #include <unistd.h>
@@ -20,3 +22,4 @@ int sigqueue(pid_t pid, int sig, const union sigval value)
 	__restore_sigs(&set);
 	return r;
 }
+*/
diff --git a/src/signal/sigsetjmp_tail.c b/src/signal/sigsetjmp_tail.c
index 78762aa2..38c16419 100644
--- a/src/signal/sigsetjmp_tail.c
+++ b/src/signal/sigsetjmp_tail.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <setjmp.h>
 #include <signal.h>
 #include "syscall.h"
@@ -9,3 +11,4 @@ int __sigsetjmp_tail(sigjmp_buf jb, int ret)
 	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, ret?p:0, ret?0:p, _NSIG/8);
 	return ret;
 }
+*/
diff --git a/src/signal/sigsuspend.c b/src/signal/sigsuspend.c
index 0b42725a..0ba443e7 100644
--- a/src/signal/sigsuspend.c
+++ b/src/signal/sigsuspend.c
@@ -4,5 +4,9 @@
 
 int sigsuspend(const sigset_t *mask)
 {
+/*
+// TODO: implement
 	return syscall_cp(SYS_rt_sigsuspend, mask, _NSIG/8);
+*/
+	return -1;
 }
diff --git a/src/signal/sigtimedwait.c b/src/signal/sigtimedwait.c
index 0739986b..63f57c53 100644
--- a/src/signal/sigtimedwait.c
+++ b/src/signal/sigtimedwait.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <signal.h>
 #include <errno.h>
 #include "syscall.h"
@@ -11,3 +13,4 @@ int sigtimedwait(const sigset_t *restrict mask, siginfo_t *restrict si, const st
 	while (ret<0 && errno==EINTR);
 	return ret;
 }
+*/
diff --git a/src/stat/chmod.c b/src/stat/chmod.c
index d4f53c56..c94e6593 100644
--- a/src/stat/chmod.c
+++ b/src/stat/chmod.c
@@ -4,9 +4,13 @@
 
 int chmod(const char *path, mode_t mode)
 {
+/*
+// TODO: implement
 #ifdef SYS_chmod
 	return syscall(SYS_chmod, path, mode);
 #else
 	return syscall(SYS_fchmodat, AT_FDCWD, path, mode);
 #endif
+*/
+	return -1;
 }
diff --git a/src/stat/fchmod.c b/src/stat/fchmod.c
index 93e1b64c..f7689a5e 100644
--- a/src/stat/fchmod.c
+++ b/src/stat/fchmod.c
@@ -7,6 +7,8 @@ void __procfdname(char *, unsigned);
 
 int fchmod(int fd, mode_t mode)
 {
+/*
+// TODO: implement
 	int ret = __syscall(SYS_fchmod, fd, mode);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
@@ -18,4 +20,6 @@ int fchmod(int fd, mode_t mode)
 #else
 	return syscall(SYS_fchmodat, AT_FDCWD, buf, mode);
 #endif
+*/
+	return -1;
 }
diff --git a/src/stat/fchmodat.c b/src/stat/fchmodat.c
deleted file mode 100644
index d94667ae..00000000
--- a/src/stat/fchmodat.c
+++ /dev/null
@@ -1,39 +0,0 @@
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <errno.h>
-#include "syscall.h"
-
-void __procfdname(char *, unsigned);
-
-int fchmodat(int fd, const char *path, mode_t mode, int flag)
-{
-	if (!flag) return syscall(SYS_fchmodat, fd, path, mode, flag);
-
-	if (flag != AT_SYMLINK_NOFOLLOW)
-		return __syscall_ret(-EINVAL);
-
-	struct stat st;
-	int ret, fd2;
-	char proc[15+3*sizeof(int)];
-
-	if ((ret = __syscall(SYS_fstatat, fd, path, &st, flag)))
-		return __syscall_ret(ret);
-	if (S_ISLNK(st.st_mode))
-		return __syscall_ret(-EOPNOTSUPP);
-
-	if ((fd2 = __syscall(SYS_openat, fd, path, O_RDONLY|O_PATH|O_NOFOLLOW|O_NOCTTY|O_CLOEXEC)) < 0) {
-		if (fd2 == -ELOOP)
-			return __syscall_ret(-EOPNOTSUPP);
-		return __syscall_ret(fd2);
-	}
-
-	__procfdname(proc, fd2);
-	ret = __syscall(SYS_fstatat, AT_FDCWD, proc, &st, 0);
-	if (!ret) {
-		if (S_ISLNK(st.st_mode)) ret = -EOPNOTSUPP;
-		else ret = __syscall(SYS_fchmodat, AT_FDCWD, proc, mode);
-	}
-
-	__syscall(SYS_close, fd2);
-	return __syscall_ret(ret);
-}
diff --git a/src/stat/fstat.c b/src/stat/fstat.c
index ab4afc0f..a120106c 100644
--- a/src/stat/fstat.c
+++ b/src/stat/fstat.c
@@ -8,6 +8,7 @@ void __procfdname(char *, unsigned);
 
 int fstat(int fd, struct stat *st)
 {
+/*
 	int ret = __syscall(SYS_fstat, fd, st);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
@@ -19,6 +20,8 @@ int fstat(int fd, struct stat *st)
 #else
 	return syscall(SYS_fstatat, AT_FDCWD, buf, st, 0);
 #endif
+*/
+	return -1;
 }
 
 LFS64(fstat);
diff --git a/src/stat/fstatat.c b/src/stat/fstatat.c
index 863d5268..ac50a3bb 100644
--- a/src/stat/fstatat.c
+++ b/src/stat/fstatat.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/stat.h>
 #include "syscall.h"
 #include "libc.h"
@@ -8,3 +10,4 @@ int fstatat(int fd, const char *restrict path, struct stat *restrict buf, int fl
 }
 
 LFS64(fstatat);
+*/
diff --git a/src/stat/lstat.c b/src/stat/lstat.c
index 5e8b84fc..8f5bf2c8 100644
--- a/src/stat/lstat.c
+++ b/src/stat/lstat.c
@@ -5,11 +5,15 @@
 
 int lstat(const char *restrict path, struct stat *restrict buf)
 {
+/*
+// TODO: implement
 #ifdef SYS_lstat
 	return syscall(SYS_lstat, path, buf);
 #else
 	return syscall(SYS_fstatat, AT_FDCWD, path, buf, AT_SYMLINK_NOFOLLOW);
 #endif
+*/
+	return -1;
 }
 
 LFS64(lstat);
diff --git a/src/stat/mkdirat.c b/src/stat/mkdirat.c
deleted file mode 100644
index b8bc2527..00000000
--- a/src/stat/mkdirat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <sys/stat.h>
-#include "syscall.h"
-
-int mkdirat(int fd, const char *path, mode_t mode)
-{
-	return syscall(SYS_mkdirat, fd, path, mode);
-}
diff --git a/src/stat/mknod.c b/src/stat/mknod.c
index beebd84e..ffab2ed4 100644
--- a/src/stat/mknod.c
+++ b/src/stat/mknod.c
@@ -4,9 +4,13 @@
 
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
+/*
+// TODO: implement
 #ifdef SYS_mknod
 	return syscall(SYS_mknod, path, mode, dev);
 #else
 	return syscall(SYS_mknodat, AT_FDCWD, path, mode, dev);
 #endif
+*/
+	return -1;
 }
diff --git a/src/stat/mknodat.c b/src/stat/mknodat.c
deleted file mode 100644
index 7c97c91a..00000000
--- a/src/stat/mknodat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <sys/stat.h>
-#include "syscall.h"
-
-int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
-{
-	return syscall(SYS_mknodat, fd, path, mode, dev);
-}
diff --git a/src/stat/stat.c b/src/stat/stat.c
index b4433a0a..0eda3807 100644
--- a/src/stat/stat.c
+++ b/src/stat/stat.c
@@ -5,11 +5,15 @@
 
 int stat(const char *restrict path, struct stat *restrict buf)
 {
+/*
+// TODO: implement
 #ifdef SYS_stat
 	return syscall(SYS_stat, path, buf);
 #else
 	return syscall(SYS_fstatat, AT_FDCWD, path, buf, 0);
 #endif
+*/
+	return -1;
 }
 
 LFS64(stat);
diff --git a/src/stat/statvfs.c b/src/stat/statvfs.c
index 30d58797..75721986 100644
--- a/src/stat/statvfs.c
+++ b/src/stat/statvfs.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/statvfs.h>
 #include <sys/statfs.h>
 #include "syscall.h"
@@ -62,3 +64,4 @@ LFS64(statvfs);
 LFS64(statfs);
 LFS64(fstatvfs);
 LFS64(fstatfs);
+*/
diff --git a/src/stat/umask.c b/src/stat/umask.c
index 5ee913e2..2f9ef07e 100644
--- a/src/stat/umask.c
+++ b/src/stat/umask.c
@@ -3,5 +3,9 @@
 
 mode_t umask(mode_t mode)
 {
+/*
+// TODO: implement
 	return syscall(SYS_umask, mode);
+*/
+	return -1;
 }
diff --git a/src/stat/utimensat.c b/src/stat/utimensat.c
index 159c8be3..cf1c9302 100644
--- a/src/stat/utimensat.c
+++ b/src/stat/utimensat.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <fcntl.h>
@@ -35,3 +37,4 @@ int utimensat(int fd, const char *path, const struct timespec times[2], int flag
 #endif
 	return __syscall_ret(r);
 }
+*/
diff --git a/src/stdio/__fdopen.c b/src/stdio/__fdopen.c
index 8d6ce813..0f21ebf0 100644
--- a/src/stdio/__fdopen.c
+++ b/src/stdio/__fdopen.c
@@ -1,6 +1,6 @@
 #include "stdio_impl.h"
 #include <stdlib.h>
-#include <sys/ioctl.h>
+//#include <sys/ioctl.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <string.h>
@@ -8,7 +8,7 @@
 FILE *__fdopen(int fd, const char *mode)
 {
 	FILE *f;
-	struct winsize wsz;
+//	struct winsize wsz;
 
 	/* Check for valid initial mode character */
 	if (!strchr("rwa", *mode)) {
@@ -26,25 +26,25 @@ FILE *__fdopen(int fd, const char *mode)
 	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
 
 	/* Apply close-on-exec flag */
-	if (strchr(mode, 'e')) __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+//	if (strchr(mode, 'e')) __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
 
 	/* Set append mode on fd if opened for append */
-	if (*mode == 'a') {
+/*	if (*mode == 'a') {
 		int flags = __syscall(SYS_fcntl, fd, F_GETFL);
 		if (!(flags & O_APPEND))
 			__syscall(SYS_fcntl, fd, F_SETFL, flags | O_APPEND);
 		f->flags |= F_APP;
 	}
-
+*/
 	f->fd = fd;
 	f->buf = (unsigned char *)f + sizeof *f + UNGET;
 	f->buf_size = BUFSIZ;
 
 	/* Activate line buffered mode for terminals */
 	f->lbf = EOF;
-	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
+/*	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
 		f->lbf = '\n';
-
+*/
 	/* Initialize op ptrs. No problem if some are unneeded. */
 	f->read = __stdio_read;
 	f->write = __stdio_write;
diff --git a/src/stdio/__fopen_rb_ca.c b/src/stdio/__fopen_rb_ca.c
index 183a5d55..369cfbed 100644
--- a/src/stdio/__fopen_rb_ca.c
+++ b/src/stdio/__fopen_rb_ca.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include "stdio_impl.h"
 #include <fcntl.h>
 #include <string.h>
@@ -20,3 +22,4 @@ FILE *__fopen_rb_ca(const char *filename, FILE *f, unsigned char *buf, size_t le
 
 	return f;
 }
+*/
diff --git a/src/stdio/__lockfile.c b/src/stdio/__lockfile.c
index 9d967d6e..cf8042a9 100644
--- a/src/stdio/__lockfile.c
+++ b/src/stdio/__lockfile.c
@@ -1,19 +1,24 @@
 #include "stdio_impl.h"
+/*
+// TODO: implement
 #include "pthread_impl.h"
-
+*/
 int __lockfile(FILE *f)
 {
+/*
 	int owner, tid = __pthread_self()->tid;
 	if (f->lock == tid)
 		return 0;
 	while ((owner = a_cas(&f->lock, 0, tid)))
 		__wait(&f->lock, &f->waiters, owner, 1);
 	return 1;
+*/
+	return 0;
 }
 
 void __unlockfile(FILE *f)
 {
-	a_store(&f->lock, 0);
+//	a_store(&f->lock, 0);
 
 	/* The following read is technically invalid under situations
 	 * of self-synchronized destruction. Another thread may have
@@ -24,5 +29,5 @@ void __unlockfile(FILE *f)
 	 * a spurious syscall will be made. If the implementation of
 	 * malloc changes, this assumption needs revisiting. */
 
-	if (f->waiters) __wake(&f->lock, 1, 1);
+//	if (f->waiters) __wake(&f->lock, 1, 1);
 }
diff --git a/src/stdio/__stdio_read.c b/src/stdio/__stdio_read.c
index f8fa6d3b..48a77b19 100644
--- a/src/stdio/__stdio_read.c
+++ b/src/stdio/__stdio_read.c
@@ -1,21 +1,20 @@
+#include <stdint.h>
 #include "stdio_impl.h"
 #include <sys/uio.h>
 
+//FIXME: it somehow works but is probably horribly broken
 size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
 {
-	struct iovec iov[2] = {
-		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
-		{ .iov_base = f->buf, .iov_len = f->buf_size }
-	};
+
 	ssize_t cnt;
+	cnt = syscall(SYS_read, f->fd, buf, len);
 
-	cnt = syscall(SYS_readv, f->fd, iov, 2);
 	if (cnt <= 0) {
 		f->flags |= F_EOF ^ ((F_ERR^F_EOF) & cnt);
 		return cnt;
 	}
-	if (cnt <= iov[0].iov_len) return cnt;
-	cnt -= iov[0].iov_len;
+	if (cnt <= len) return cnt;
+	cnt -= len;
 	f->rpos = f->buf;
 	f->rend = f->buf + cnt;
 	if (f->buf_size) buf[len-1] = *f->rpos++;
diff --git a/src/stdio/__stdio_seek.c b/src/stdio/__stdio_seek.c
index 13e06a66..382ec5f0 100644
--- a/src/stdio/__stdio_seek.c
+++ b/src/stdio/__stdio_seek.c
@@ -1,13 +1,20 @@
+
+// TODO: implement
 #include "stdio_impl.h"
 
 off_t __stdio_seek(FILE *f, off_t off, int whence)
 {
+	__asm__ __volatile__ ("int $0");
 	off_t ret;
 #ifdef SYS__llseek
 	if (syscall(SYS__llseek, f->fd, off>>32, off, &ret, whence)<0)
 		ret = -1;
 #else
+#ifdef SYS_lseek
 	ret = syscall(SYS_lseek, f->fd, off, whence);
+#else
+	ret = -1;
+#endif
 #endif
 	return ret;
 }
diff --git a/src/stdio/__stdio_write.c b/src/stdio/__stdio_write.c
index d2d89475..aabd5e0d 100644
--- a/src/stdio/__stdio_write.c
+++ b/src/stdio/__stdio_write.c
@@ -3,6 +3,7 @@
 
 size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 {
+	unsigned int i = 0;
 	struct iovec iovs[2] = {
 		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
 		{ .iov_base = (void *)buf, .iov_len = len }
@@ -12,7 +13,10 @@ size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 	int iovcnt = 2;
 	ssize_t cnt;
 	for (;;) {
-		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
+//		__asm__ __volatile__("int $0x80" : : "a" (0xFF), "b" (iov[0].iov_base), "c" (iov[0].iov_len));
+		cnt = syscall(SYS_write, f->fd, iov[0].iov_base, iov[0].iov_len);
+//		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
+//		__asm__ __volatile__("int $0x80" : : "a" (0xFF), "b" (cnt), "c"(rem));
 		if (cnt == rem) {
 			f->wend = f->buf + f->buf_size;
 			f->wpos = f->wbase = f->buf;
@@ -24,7 +28,7 @@ size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
 		}
 		rem -= cnt;
-		if (cnt > iov[0].iov_len) {
+		if (cnt >= iov[0].iov_len) {
 			cnt -= iov[0].iov_len;
 			iov++; iovcnt--;
 		}
diff --git a/src/stdio/__stdout_write.c b/src/stdio/__stdout_write.c
index dd1ec60f..9588c990 100644
--- a/src/stdio/__stdout_write.c
+++ b/src/stdio/__stdout_write.c
@@ -5,7 +5,7 @@ size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
 {
 	struct winsize wsz;
 	f->write = __stdio_write;
-	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
-		f->lbf = -1;
+//	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
+//		f->lbf = -1;
 	return __stdio_write(f, buf, len);
 }
diff --git a/src/stdio/flockfile.c b/src/stdio/flockfile.c
deleted file mode 100644
index a196c1ef..00000000
--- a/src/stdio/flockfile.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "stdio_impl.h"
-#include "pthread_impl.h"
-
-void flockfile(FILE *f)
-{
-	while (ftrylockfile(f)) {
-		int owner = f->lock;
-		if (owner) __wait(&f->lock, &f->waiters, owner, 1);
-	}
-}
diff --git a/src/stdio/fopen.c b/src/stdio/fopen.c
index 252f0824..7caa35d5 100644
--- a/src/stdio/fopen.c
+++ b/src/stdio/fopen.c
@@ -20,8 +20,8 @@ FILE *fopen(const char *restrict filename, const char *restrict mode)
 
 	fd = sys_open(filename, flags, 0666);
 	if (fd < 0) return 0;
-	if (flags & O_CLOEXEC)
-		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+//	if (flags & O_CLOEXEC)
+//		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
 
 	f = __fdopen(fd, mode);
 	if (f) return f;
diff --git a/src/stdio/freopen.c b/src/stdio/freopen.c
index 6c1b575f..85a03429 100644
--- a/src/stdio/freopen.c
+++ b/src/stdio/freopen.c
@@ -21,11 +21,12 @@ FILE *freopen(const char *restrict filename, const char *restrict mode, FILE *re
 	fflush(f);
 
 	if (!filename) {
-		if (fl&O_CLOEXEC)
-			__syscall(SYS_fcntl, f->fd, F_SETFD, FD_CLOEXEC);
+//		if (fl&O_CLOEXEC)
+//			__syscall(SYS_fcntl, f->fd, F_SETFD, FD_CLOEXEC);
 		fl &= ~(O_CREAT|O_EXCL|O_CLOEXEC);
-		if (syscall(SYS_fcntl, f->fd, F_SETFL, fl) < 0)
+//		if (syscall(SYS_fcntl, f->fd, F_SETFL, fl) < 0)
 			goto fail;
+// FIXME: ^
 	} else {
 		f2 = fopen(filename, mode);
 		if (!f2) goto fail;
diff --git a/src/stdio/ftrylockfile.c b/src/stdio/ftrylockfile.c
deleted file mode 100644
index eb13c839..00000000
--- a/src/stdio/ftrylockfile.c
+++ /dev/null
@@ -1,40 +0,0 @@
-#include "stdio_impl.h"
-#include "pthread_impl.h"
-#include <limits.h>
-
-void __do_orphaned_stdio_locks()
-{
-	FILE *f;
-	for (f=__pthread_self()->stdio_locks; f; f=f->next_locked)
-		a_store(&f->lock, 0x40000000);
-}
-
-void __unlist_locked_file(FILE *f)
-{
-	if (f->lockcount) {
-		if (f->next_locked) f->next_locked->prev_locked = f->prev_locked;
-		if (f->prev_locked) f->prev_locked->next_locked = f->next_locked;
-		else __pthread_self()->stdio_locks = f->next_locked;
-	}
-}
-
-int ftrylockfile(FILE *f)
-{
-	pthread_t self = __pthread_self();
-	int tid = self->tid;
-	if (f->lock == tid) {
-		if (f->lockcount == LONG_MAX)
-			return -1;
-		f->lockcount++;
-		return 0;
-	}
-	if (f->lock < 0) f->lock = 0;
-	if (f->lock || a_cas(&f->lock, 0, tid))
-		return -1;
-	f->lockcount = 1;
-	f->prev_locked = 0;
-	f->next_locked = self->stdio_locks;
-	if (f->next_locked) f->next_locked->prev_locked = f;
-	self->stdio_locks = f;
-	return 0;
-}
diff --git a/src/stdio/funlockfile.c b/src/stdio/funlockfile.c
deleted file mode 100644
index 30a07ef4..00000000
--- a/src/stdio/funlockfile.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "stdio_impl.h"
-#include "pthread_impl.h"
-
-void __unlist_locked_file(FILE *);
-
-void funlockfile(FILE *f)
-{
-	if (f->lockcount == 1) {
-		__unlist_locked_file(f);
-		f->lockcount = 0;
-		__unlockfile(f);
-	} else {
-		f->lockcount--;
-	}
-}
diff --git a/src/stdio/pclose.c b/src/stdio/pclose.c
index 080a4262..b93c1e31 100644
--- a/src/stdio/pclose.c
+++ b/src/stdio/pclose.c
@@ -1,3 +1,4 @@
+/*
 #include "stdio_impl.h"
 #include <errno.h>
 #include <unistd.h>
@@ -11,3 +12,4 @@ int pclose(FILE *f)
 	if (r<0) return __syscall_ret(r);
 	return status;
 }
+*/
diff --git a/src/stdio/remove.c b/src/stdio/remove.c
index 942e301a..aeb5afd0 100644
--- a/src/stdio/remove.c
+++ b/src/stdio/remove.c
@@ -13,7 +13,12 @@ int remove(const char *path)
 #ifdef SYS_rmdir
 	if (r==-EISDIR) r = __syscall(SYS_rmdir, path);
 #else
+#ifdef SYS_unlink
+	if (r==-EISDIR)
+		__asm__ __volatile__ ("hlt");
+#else
 	if (r==-EISDIR) r = __syscall(SYS_unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
 #endif
+#endif
 	return __syscall_ret(r);
 }
diff --git a/src/stdio/rename.c b/src/stdio/rename.c
index 04c90c01..a63c9017 100644
--- a/src/stdio/rename.c
+++ b/src/stdio/rename.c
@@ -4,9 +4,13 @@
 
 int rename(const char *old, const char *new)
 {
+/*
+// TODO: implement
 #ifdef SYS_rename
 	return syscall(SYS_rename, old, new);
 #else
 	return syscall(SYS_renameat, AT_FDCWD, old, AT_FDCWD, new);
 #endif
+*/
+	return -1;
 }
diff --git a/src/stdio/tempnam.c b/src/stdio/tempnam.c
index 5a559752..43769b9f 100644
--- a/src/stdio/tempnam.c
+++ b/src/stdio/tempnam.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
@@ -47,3 +49,4 @@ char *tempnam(const char *dir, const char *pfx)
 	}
 	return 0;
 }
+*/
diff --git a/src/stdio/tmpnam.c b/src/stdio/tmpnam.c
index 449eb9b0..c0cf74aa 100644
--- a/src/stdio/tmpnam.c
+++ b/src/stdio/tmpnam.c
@@ -11,6 +11,8 @@ char *__randname(char *);
 
 char *tmpnam(char *buf)
 {
+/*
+// TODO: implement
 	static char internal[L_tmpnam];
 	char s[] = "/tmp/tmpnam_XXXXXX";
 	int try;
@@ -25,5 +27,6 @@ char *tmpnam(char *buf)
 #endif
 		if (r == -ENOENT) return strcpy(buf ? buf : internal, s);
 	}
+*/
 	return 0;
 }
diff --git a/src/stdio/vfprintf.c b/src/stdio/vfprintf.c
index 50fb55c1..79224942 100644
--- a/src/stdio/vfprintf.c
+++ b/src/stdio/vfprintf.c
@@ -131,7 +131,9 @@ static void pop_arg(union arg *arg, int type, va_list *ap)
 
 static void out(FILE *f, const char *s, size_t l)
 {
-	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
+//	__asm__ __volatile__ ("int $80" : : "a" (0xFF), "b" (l));
+
+	if (!(f->flags & F_ERR)) {__fwritex((void *)s, l, f);} else {/* __asm__ __volatile__ ("hlt");*/ }
 }
 
 static void pad(FILE *f, char c, int w, int l, int fl)
diff --git a/src/string/i386-myunix b/src/string/i386-myunix
new file mode 120000
index 00000000..fd32fa4e
--- /dev/null
+++ b/src/string/i386-myunix
@@ -0,0 +1 @@
+i386
\ No newline at end of file
diff --git a/src/termios/tcdrain.c b/src/termios/tcdrain.c
index 6e43afb7..61996838 100644
--- a/src/termios/tcdrain.c
+++ b/src/termios/tcdrain.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <termios.h>
 #include <sys/ioctl.h>
 #include "libc.h"
@@ -7,3 +9,4 @@ int tcdrain(int fd)
 {
 	return syscall_cp(SYS_ioctl, fd, TCSBRK, 1);
 }
+*/
diff --git a/src/termios/tcflow.c b/src/termios/tcflow.c
index c7fc3fe2..6359f92e 100644
--- a/src/termios/tcflow.c
+++ b/src/termios/tcflow.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <termios.h>
 #include <sys/ioctl.h>
 
@@ -5,3 +7,4 @@ int tcflow(int fd, int action)
 {
 	return ioctl(fd, TCXONC, action);
 }
+*/
diff --git a/src/termios/tcflush.c b/src/termios/tcflush.c
index 50222669..fdefa2f7 100644
--- a/src/termios/tcflush.c
+++ b/src/termios/tcflush.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <termios.h>
 #include <sys/ioctl.h>
 
@@ -5,3 +7,4 @@ int tcflush(int fd, int queue)
 {
 	return ioctl(fd, TCFLSH, queue);
 }
+*/
diff --git a/src/thread/__futex.c b/src/thread/__futex.c
index 96307c08..817751ca 100644
--- a/src/thread/__futex.c
+++ b/src/thread/__futex.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include "futex.h"
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ int __futex(volatile int *addr, int op, int val, void *ts)
 {
 	return syscall(SYS_futex, addr, op, val, ts);
 }
+*/
diff --git a/src/thread/__lock.c b/src/thread/__lock.c
index 45557c88..a33df603 100644
--- a/src/thread/__lock.c
+++ b/src/thread/__lock.c
@@ -1,5 +1,7 @@
+/*
+// TODO: implement
 #include "pthread_impl.h"
-
+*/
 /* This lock primitive combines a flag (in the sign bit) and a
  * congestion count (= threads inside the critical section, CS) in a
  * single int that is accessed through atomic operations. The states
@@ -15,15 +17,15 @@
  * or in an equivalent formulation x is the congestion count or'ed
  * with INT_MIN as a lock flag.
  */
-
+/*
 void __lock(volatile int *l)
 {
 	if (!libc.threads_minus_1) return;
-	/* fast path: INT_MIN for the lock, +1 for the congestion */
-	int current = a_cas(l, 0, INT_MIN + 1);
+*/	/* fast path: INT_MIN for the lock, +1 for the congestion */
+/*	int current = a_cas(l, 0, INT_MIN + 1);
 	if (!current) return;
-	/* A first spin loop, for medium congestion. */
-	for (unsigned i = 0; i < 10; ++i) {
+*/	/* A first spin loop, for medium congestion. */
+/*	for (unsigned i = 0; i < 10; ++i) {
 		if (current < 0) current -= INT_MIN + 1;
 		// assertion: current >= 0
 		int val = a_cas(l, current, INT_MIN + (current + 1));
@@ -32,18 +34,18 @@ void __lock(volatile int *l)
 	}
 	// Spinning failed, so mark ourselves as being inside the CS.
 	current = a_fetch_add(l, 1) + 1;
-	/* The main lock acquisition loop for heavy congestion. The only
+*/	/* The main lock acquisition loop for heavy congestion. The only
 	 * change to the value performed inside that loop is a successful
 	 * lock via the CAS that acquires the lock. */
-	for (;;) {
-		/* We can only go into wait, if we know that somebody holds the
+/*	for (;;) {
+*/		/* We can only go into wait, if we know that somebody holds the
 		 * lock and will eventually wake us up, again. */
-		if (current < 0) {
+/*		if (current < 0) {
 			__futexwait(l, current, 1);
 			current -= INT_MIN + 1;
 		}
-		/* assertion: current > 0, the count includes us already. */
-		int val = a_cas(l, current, INT_MIN + current);
+*/		/* assertion: current > 0, the count includes us already. */
+/*		int val = a_cas(l, current, INT_MIN + current);
 		if (val == current) return;
 		current = val;
 	}
@@ -51,10 +53,11 @@ void __lock(volatile int *l)
 
 void __unlock(volatile int *l)
 {
-	/* Check l[0] to see if we are multi-threaded. */
-	if (l[0] < 0) {
+*/	/* Check l[0] to see if we are multi-threaded. */
+/*	if (l[0] < 0) {
 		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
 			__wake(l, 1, 1);
 		}
 	}
 }
+*/
diff --git a/src/thread/__timedwait.c b/src/thread/__timedwait.c
index d2079c88..c38c51f6 100644
--- a/src/thread/__timedwait.c
+++ b/src/thread/__timedwait.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <pthread.h>
 #include <time.h>
 #include <errno.h>
@@ -44,3 +46,4 @@ int __timedwait(volatile int *addr, int val,
 	__pthread_setcancelstate(cs, 0);
 	return r;
 }
+*/
diff --git a/src/thread/__wait.c b/src/thread/__wait.c
index dc33c1a3..6b7b59cb 100644
--- a/src/thread/__wait.c
+++ b/src/thread/__wait.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include "pthread_impl.h"
 
 void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
@@ -15,3 +17,4 @@ void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
 	}
 	if (waiters) a_dec(waiters);
 }
+*/
diff --git a/src/thread/i386-myunix/__set_thread_area.s b/src/thread/i386-myunix/__set_thread_area.s
new file mode 100644
index 00000000..3a558fb0
--- /dev/null
+++ b/src/thread/i386-myunix/__set_thread_area.s
@@ -0,0 +1,45 @@
+.text
+.global __set_thread_area
+.type   __set_thread_area,@function
+__set_thread_area:
+	push %ebx
+	push $0x51
+	push $0xfffff
+	push 16(%esp)
+	call 1f
+1:	addl $4f-1b,(%esp)
+	pop %ecx
+	mov (%ecx),%edx
+	push %edx
+	mov %esp,%ebx
+	xor %eax,%eax
+	mov $243,%al
+	int $128
+	testl %eax,%eax
+	jnz 2f
+	movl (%esp),%edx
+	movl %edx,(%ecx)
+	leal 3(,%edx,8),%edx
+3:	movw %dx,%gs
+1:
+	addl $16,%esp
+	popl %ebx
+	ret
+2:
+	mov %ebx,%ecx
+	xor %ebx,%ebx
+	xor %edx,%edx
+	mov %ebx,(%esp)
+	mov $1,%bl
+	mov $16,%dl
+	mov $123,%al
+	int $128
+	testl %eax,%eax
+	jnz 1b
+	mov $7,%dl
+	inc %al
+	jmp 3b
+
+.data
+	.align 4
+4:	.long -1
diff --git a/src/thread/i386-myunix/__unmapself.s b/src/thread/i386-myunix/__unmapself.s
new file mode 100644
index 00000000..d6569594
--- /dev/null
+++ b/src/thread/i386-myunix/__unmapself.s
@@ -0,0 +1,11 @@
+.text
+.global __unmapself
+.type   __unmapself,@function
+__unmapself:
+	movl $91,%eax
+	movl 4(%esp),%ebx
+	movl 8(%esp),%ecx
+	int $128
+	xorl %ebx,%ebx
+	movl $1,%eax
+	int $128
diff --git a/src/thread/i386-myunix/clone.s b/src/thread/i386-myunix/clone.s
new file mode 100644
index 00000000..52fe7efb
--- /dev/null
+++ b/src/thread/i386-myunix/clone.s
@@ -0,0 +1,48 @@
+.text
+.global __clone
+.type   __clone,@function
+__clone:
+	push %ebp
+	mov %esp,%ebp
+	push %ebx
+	push %esi
+	push %edi
+
+	xor %eax,%eax
+	push $0x51
+	mov %gs,%ax
+	push $0xfffff
+	shr $3,%eax
+	push 28(%ebp)
+	push %eax
+	mov $120,%al
+
+	mov 12(%ebp),%ecx
+	mov 16(%ebp),%ebx
+	and $-16,%ecx
+	sub $16,%ecx
+	mov 20(%ebp),%edi
+	mov %edi,(%ecx)
+	mov 24(%ebp),%edx
+	mov %esp,%esi
+	mov 32(%ebp),%edi
+	mov 8(%ebp),%ebp
+	int $128
+	test %eax,%eax
+	jnz 1f
+
+	mov %ebp,%eax
+	xor %ebp,%ebp
+	call *%eax
+	mov %eax,%ebx
+	xor %eax,%eax
+	inc %eax
+	int $128
+	hlt
+
+1:	add $16,%esp
+	pop %edi
+	pop %esi
+	pop %ebx
+	pop %ebp
+	ret
diff --git a/src/thread/i386-myunix/syscall_cp.s b/src/thread/i386-myunix/syscall_cp.s
new file mode 100644
index 00000000..7dce1eb3
--- /dev/null
+++ b/src/thread/i386-myunix/syscall_cp.s
@@ -0,0 +1,41 @@
+.text
+.global __cp_begin
+.hidden __cp_begin
+.global __cp_end
+.hidden __cp_end
+.global __cp_cancel
+.hidden __cp_cancel
+.hidden __cancel
+.global __syscall_cp_asm
+.hidden __syscall_cp_asm
+.type   __syscall_cp_asm,@function
+__syscall_cp_asm:
+	mov 4(%esp),%ecx
+	pushl %ebx
+	pushl %esi
+	pushl %edi
+	pushl %ebp
+__cp_begin:
+	movl (%ecx),%eax
+	testl %eax,%eax
+	jnz __cp_cancel
+	movl 24(%esp),%eax
+	movl 28(%esp),%ebx
+	movl 32(%esp),%ecx
+	movl 36(%esp),%edx
+	movl 40(%esp),%esi
+	movl 44(%esp),%edi
+	movl 48(%esp),%ebp
+	int $128
+__cp_end:
+	popl %ebp
+	popl %edi
+	popl %esi
+	popl %ebx
+	ret
+__cp_cancel:
+	popl %ebp
+	popl %edi
+	popl %esi
+	popl %ebx
+	jmp __cancel
diff --git a/src/thread/i386-myunix/tls.s b/src/thread/i386-myunix/tls.s
new file mode 100644
index 00000000..76d5d462
--- /dev/null
+++ b/src/thread/i386-myunix/tls.s
@@ -0,0 +1,17 @@
+.text
+.global ___tls_get_addr
+.type ___tls_get_addr,@function
+___tls_get_addr:
+	mov %gs:4,%edx
+	mov (%eax),%ecx
+	cmp %ecx,(%edx)
+	jc 1f
+	mov 4(%eax),%eax
+	add (%edx,%ecx,4),%eax
+	ret
+1:	push %eax
+.weak __tls_get_new
+.hidden __tls_get_new
+	call __tls_get_new
+	pop %edx
+	ret
diff --git a/src/thread/pthread_atfork.c b/src/thread/pthread_atfork.c
deleted file mode 100644
index c6f77b3f..00000000
--- a/src/thread/pthread_atfork.c
+++ /dev/null
@@ -1,48 +0,0 @@
-#include <pthread.h>
-#include "libc.h"
-
-static struct atfork_funcs {
-	void (*prepare)(void);
-	void (*parent)(void);
-	void (*child)(void);
-	struct atfork_funcs *prev, *next;
-} *funcs;
-
-static volatile int lock[1];
-
-void __fork_handler(int who)
-{
-	struct atfork_funcs *p;
-	if (!funcs) return;
-	if (who < 0) {
-		LOCK(lock);
-		for (p=funcs; p; p = p->next) {
-			if (p->prepare) p->prepare();
-			funcs = p;
-		}
-	} else {
-		for (p=funcs; p; p = p->prev) {
-			if (!who && p->parent) p->parent();
-			else if (who && p->child) p->child();
-			funcs = p;
-		}
-		UNLOCK(lock);
-	}
-}
-
-int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
-{
-	struct atfork_funcs *new = malloc(sizeof *new);
-	if (!new) return -1;
-
-	LOCK(lock);
-	new->next = funcs;
-	new->prev = 0;
-	new->prepare = prepare;
-	new->parent = parent;
-	new->child = child;
-	if (funcs) funcs->prev = new;
-	funcs = new;
-	UNLOCK(lock);
-	return 0;
-}
diff --git a/src/thread/pthread_attr_destroy.c b/src/thread/pthread_attr_destroy.c
deleted file mode 100644
index b5845dd0..00000000
--- a/src/thread/pthread_attr_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_destroy(pthread_attr_t *a)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_attr_get.c b/src/thread/pthread_attr_get.c
deleted file mode 100644
index 4aa5afdb..00000000
--- a/src/thread/pthread_attr_get.c
+++ /dev/null
@@ -1,98 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_getdetachstate(const pthread_attr_t *a, int *state)
-{
-	*state = a->_a_detach;
-	return 0;
-}
-int pthread_attr_getguardsize(const pthread_attr_t *restrict a, size_t *restrict size)
-{
-	*size = a->_a_guardsize;
-	return 0;
-}
-
-int pthread_attr_getinheritsched(const pthread_attr_t *restrict a, int *restrict inherit)
-{
-	*inherit = a->_a_sched;
-	return 0;
-}
-
-int pthread_attr_getschedparam(const pthread_attr_t *restrict a, struct sched_param *restrict param)
-{
-	param->sched_priority = a->_a_prio;
-	return 0;
-}
-
-int pthread_attr_getschedpolicy(const pthread_attr_t *restrict a, int *restrict policy)
-{
-	*policy = a->_a_policy;
-	return 0;
-}
-
-int pthread_attr_getscope(const pthread_attr_t *restrict a, int *restrict scope)
-{
-	*scope = PTHREAD_SCOPE_SYSTEM;
-	return 0;
-}
-
-int pthread_attr_getstack(const pthread_attr_t *restrict a, void **restrict addr, size_t *restrict size)
-{
-	if (!a->_a_stackaddr)
-		return EINVAL;
-	*size = a->_a_stacksize;
-	*addr = (void *)(a->_a_stackaddr - *size);
-	return 0;
-}
-
-int pthread_attr_getstacksize(const pthread_attr_t *restrict a, size_t *restrict size)
-{
-	*size = a->_a_stacksize;
-	return 0;
-}
-
-int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict a, int *restrict pshared)
-{
-	*pshared = !!a->__attr;
-	return 0;
-}
-
-int pthread_condattr_getclock(const pthread_condattr_t *restrict a, clockid_t *restrict clk)
-{
-	*clk = a->__attr & 0x7fffffff;
-	return 0;
-}
-
-int pthread_condattr_getpshared(const pthread_condattr_t *restrict a, int *restrict pshared)
-{
-	*pshared = a->__attr>>31;
-	return 0;
-}
-
-int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict a, int *restrict protocol)
-{
-	*protocol = PTHREAD_PRIO_NONE;
-	return 0;
-}
-int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict a, int *restrict pshared)
-{
-	*pshared = a->__attr / 128U % 2;
-	return 0;
-}
-
-int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict a, int *restrict robust)
-{
-	*robust = a->__attr / 4U % 2;
-	return 0;
-}
-
-int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict a, int *restrict type)
-{
-	*type = a->__attr & 3;
-	return 0;
-}
-
-int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict a, int *restrict pshared)
-{
-	*pshared = a->__attr[0];
-	return 0;
-}
diff --git a/src/thread/pthread_attr_init.c b/src/thread/pthread_attr_init.c
deleted file mode 100644
index 8f6e3374..00000000
--- a/src/thread/pthread_attr_init.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_init(pthread_attr_t *a)
-{
-	*a = (pthread_attr_t){0};
-	a->_a_stacksize = DEFAULT_STACK_SIZE;
-	a->_a_guardsize = DEFAULT_GUARD_SIZE;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setdetachstate.c b/src/thread/pthread_attr_setdetachstate.c
deleted file mode 100644
index 1b712783..00000000
--- a/src/thread/pthread_attr_setdetachstate.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setdetachstate(pthread_attr_t *a, int state)
-{
-	if (state > 1U) return EINVAL;
-	a->_a_detach = state;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setguardsize.c b/src/thread/pthread_attr_setguardsize.c
deleted file mode 100644
index 1c5c60ac..00000000
--- a/src/thread/pthread_attr_setguardsize.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setguardsize(pthread_attr_t *a, size_t size)
-{
-	if (size > SIZE_MAX/8) return EINVAL;
-	a->_a_guardsize = size;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setinheritsched.c b/src/thread/pthread_attr_setinheritsched.c
deleted file mode 100644
index c91d8f83..00000000
--- a/src/thread/pthread_attr_setinheritsched.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit)
-{
-	if (inherit > 1U) return EINVAL;
-	a->_a_sched = inherit;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setschedparam.c b/src/thread/pthread_attr_setschedparam.c
deleted file mode 100644
index d4c1204f..00000000
--- a/src/thread/pthread_attr_setschedparam.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param)
-{
-	a->_a_prio = param->sched_priority;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setschedpolicy.c b/src/thread/pthread_attr_setschedpolicy.c
deleted file mode 100644
index bb71f393..00000000
--- a/src/thread/pthread_attr_setschedpolicy.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy)
-{
-	a->_a_policy = policy;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setscope.c b/src/thread/pthread_attr_setscope.c
deleted file mode 100644
index 46b520c0..00000000
--- a/src/thread/pthread_attr_setscope.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setscope(pthread_attr_t *a, int scope)
-{
-	switch (scope) {
-	case PTHREAD_SCOPE_SYSTEM:
-		return 0;
-	case PTHREAD_SCOPE_PROCESS:
-		return ENOTSUP;
-	default:
-		return EINVAL;
-	}
-}
diff --git a/src/thread/pthread_attr_setstack.c b/src/thread/pthread_attr_setstack.c
deleted file mode 100644
index 1eddcbd6..00000000
--- a/src/thread/pthread_attr_setstack.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size)
-{
-	if (size-PTHREAD_STACK_MIN > SIZE_MAX/4) return EINVAL;
-	a->_a_stackaddr = (size_t)addr + size;
-	a->_a_stacksize = size;
-	return 0;
-}
diff --git a/src/thread/pthread_attr_setstacksize.c b/src/thread/pthread_attr_setstacksize.c
deleted file mode 100644
index 9c6a8806..00000000
--- a/src/thread/pthread_attr_setstacksize.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_attr_setstacksize(pthread_attr_t *a, size_t size)
-{
-	if (size-PTHREAD_STACK_MIN > SIZE_MAX/4) return EINVAL;
-	a->_a_stackaddr = 0;
-	a->_a_stacksize = size;
-	return 0;
-}
diff --git a/src/thread/pthread_barrier_destroy.c b/src/thread/pthread_barrier_destroy.c
deleted file mode 100644
index 4ce0b2e1..00000000
--- a/src/thread/pthread_barrier_destroy.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_barrier_destroy(pthread_barrier_t *b)
-{
-	if (b->_b_limit < 0) {
-		if (b->_b_lock) {
-			int v;
-			a_or(&b->_b_lock, INT_MIN);
-			while ((v = b->_b_lock) & INT_MAX)
-				__wait(&b->_b_lock, 0, v, 0);
-		}
-		__vm_wait();
-	}
-	return 0;
-}
diff --git a/src/thread/pthread_barrier_init.c b/src/thread/pthread_barrier_init.c
deleted file mode 100644
index 4c3cb28d..00000000
--- a/src/thread/pthread_barrier_init.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_barrier_init(pthread_barrier_t *restrict b, const pthread_barrierattr_t *restrict a, unsigned count)
-{
-	if (count-1 > INT_MAX-1) return EINVAL;
-	*b = (pthread_barrier_t){ ._b_limit = count-1 | (a?a->__attr:0) };
-	return 0;
-}
diff --git a/src/thread/pthread_barrier_wait.c b/src/thread/pthread_barrier_wait.c
deleted file mode 100644
index cc2a8bbf..00000000
--- a/src/thread/pthread_barrier_wait.c
+++ /dev/null
@@ -1,111 +0,0 @@
-#include "pthread_impl.h"
-
-static int pshared_barrier_wait(pthread_barrier_t *b)
-{
-	int limit = (b->_b_limit & INT_MAX) + 1;
-	int ret = 0;
-	int v, w;
-
-	if (limit==1) return PTHREAD_BARRIER_SERIAL_THREAD;
-
-	while ((v=a_cas(&b->_b_lock, 0, limit)))
-		__wait(&b->_b_lock, &b->_b_waiters, v, 0);
-
-	/* Wait for <limit> threads to get to the barrier */
-	if (++b->_b_count == limit) {
-		a_store(&b->_b_count, 0);
-		ret = PTHREAD_BARRIER_SERIAL_THREAD;
-		if (b->_b_waiters2) __wake(&b->_b_count, -1, 0);
-	} else {
-		a_store(&b->_b_lock, 0);
-		if (b->_b_waiters) __wake(&b->_b_lock, 1, 0);
-		while ((v=b->_b_count)>0)
-			__wait(&b->_b_count, &b->_b_waiters2, v, 0);
-	}
-
-	__vm_lock();
-
-	/* Ensure all threads have a vm lock before proceeding */
-	if (a_fetch_add(&b->_b_count, -1)==1-limit) {
-		a_store(&b->_b_count, 0);
-		if (b->_b_waiters2) __wake(&b->_b_count, -1, 0);
-	} else {
-		while ((v=b->_b_count))
-			__wait(&b->_b_count, &b->_b_waiters2, v, 0);
-	}
-	
-	/* Perform a recursive unlock suitable for self-sync'd destruction */
-	do {
-		v = b->_b_lock;
-		w = b->_b_waiters;
-	} while (a_cas(&b->_b_lock, v, v==INT_MIN+1 ? 0 : v-1) != v);
-
-	/* Wake a thread waiting to reuse or destroy the barrier */
-	if (v==INT_MIN+1 || (v==1 && w))
-		__wake(&b->_b_lock, 1, 0);
-
-	__vm_unlock();
-
-	return ret;
-}
-
-struct instance
-{
-	volatile int count;
-	volatile int last;
-	volatile int waiters;
-	volatile int finished;
-};
-
-int pthread_barrier_wait(pthread_barrier_t *b)
-{
-	int limit = b->_b_limit;
-	struct instance *inst;
-
-	/* Trivial case: count was set at 1 */
-	if (!limit) return PTHREAD_BARRIER_SERIAL_THREAD;
-
-	/* Process-shared barriers require a separate, inefficient wait */
-	if (limit < 0) return pshared_barrier_wait(b);
-
-	/* Otherwise we need a lock on the barrier object */
-	while (a_swap(&b->_b_lock, 1))
-		__wait(&b->_b_lock, &b->_b_waiters, 1, 1);
-	inst = b->_b_inst;
-
-	/* First thread to enter the barrier becomes the "instance owner" */
-	if (!inst) {
-		struct instance new_inst = { 0 };
-		int spins = 200;
-		b->_b_inst = inst = &new_inst;
-		a_store(&b->_b_lock, 0);
-		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
-		while (spins-- && !inst->finished)
-			a_spin();
-		a_inc(&inst->finished);
-		while (inst->finished == 1)
-			__syscall(SYS_futex,&inst->finished,FUTEX_WAIT|FUTEX_PRIVATE,1,0) != -ENOSYS
-			|| __syscall(SYS_futex,&inst->finished,FUTEX_WAIT,1,0);
-		return PTHREAD_BARRIER_SERIAL_THREAD;
-	}
-
-	/* Last thread to enter the barrier wakes all non-instance-owners */
-	if (++inst->count == limit) {
-		b->_b_inst = 0;
-		a_store(&b->_b_lock, 0);
-		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
-		a_store(&inst->last, 1);
-		if (inst->waiters)
-			__wake(&inst->last, -1, 1);
-	} else {
-		a_store(&b->_b_lock, 0);
-		if (b->_b_waiters) __wake(&b->_b_lock, 1, 1);
-		__wait(&inst->last, &inst->waiters, 0, 1);
-	}
-
-	/* Last thread to exit the barrier wakes the instance owner */
-	if (a_fetch_add(&inst->count,-1)==1 && a_fetch_add(&inst->finished,1))
-		__wake(&inst->finished, 1, 1);
-
-	return 0;
-}
diff --git a/src/thread/pthread_barrierattr_destroy.c b/src/thread/pthread_barrierattr_destroy.c
deleted file mode 100644
index adec738f..00000000
--- a/src/thread/pthread_barrierattr_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_barrierattr_destroy(pthread_barrierattr_t *a)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_barrierattr_init.c b/src/thread/pthread_barrierattr_init.c
deleted file mode 100644
index fa742bb7..00000000
--- a/src/thread/pthread_barrierattr_init.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_barrierattr_init(pthread_barrierattr_t *a)
-{
-	*a = (pthread_barrierattr_t){0};
-	return 0;
-}
diff --git a/src/thread/pthread_barrierattr_setpshared.c b/src/thread/pthread_barrierattr_setpshared.c
deleted file mode 100644
index b391461e..00000000
--- a/src/thread/pthread_barrierattr_setpshared.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_barrierattr_setpshared(pthread_barrierattr_t *a, int pshared)
-{
-	a->__attr = pshared ? INT_MIN : 0;
-	return 0;
-}
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
deleted file mode 100644
index 3d229223..00000000
--- a/src/thread/pthread_cancel.c
+++ /dev/null
@@ -1,97 +0,0 @@
-#define _GNU_SOURCE
-#include <string.h>
-#include "pthread_impl.h"
-#include "syscall.h"
-#include "libc.h"
-
-__attribute__((__visibility__("hidden")))
-long __cancel(), __syscall_cp_asm(), __syscall_cp_c();
-
-long __cancel()
-{
-	pthread_t self = __pthread_self();
-	if (self->canceldisable == PTHREAD_CANCEL_ENABLE || self->cancelasync)
-		pthread_exit(PTHREAD_CANCELED);
-	self->canceldisable = PTHREAD_CANCEL_DISABLE;
-	return -ECANCELED;
-}
-
-long __syscall_cp_asm(volatile void *, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
-
-long __syscall_cp_c(syscall_arg_t nr,
-                    syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
-                    syscall_arg_t x, syscall_arg_t y, syscall_arg_t z)
-{
-	pthread_t self;
-	long r;
-	int st;
-
-	if ((st=(self=__pthread_self())->canceldisable)
-	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
-		return __syscall(nr, u, v, w, x, y, z);
-
-	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
-	if (r==-EINTR && nr!=SYS_close && self->cancel &&
-	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
-		r = __cancel();
-	return r;
-}
-
-static void _sigaddset(sigset_t *set, int sig)
-{
-	unsigned s = sig-1;
-	set->__bits[s/8/sizeof *set->__bits] |= 1UL<<(s&8*sizeof *set->__bits-1);
-}
-
-__attribute__((__visibility__("hidden")))
-extern const char __cp_begin[1], __cp_end[1], __cp_cancel[1];
-
-static void cancel_handler(int sig, siginfo_t *si, void *ctx)
-{
-	pthread_t self = __pthread_self();
-	ucontext_t *uc = ctx;
-	uintptr_t pc = uc->uc_mcontext.MC_PC;
-
-	a_barrier();
-	if (!self->cancel || self->canceldisable == PTHREAD_CANCEL_DISABLE) return;
-
-	_sigaddset(&uc->uc_sigmask, SIGCANCEL);
-
-	if (self->cancelasync || pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
-		uc->uc_mcontext.MC_PC = (uintptr_t)__cp_cancel;
-		return;
-	}
-
-	__syscall(SYS_tkill, self->tid, SIGCANCEL);
-}
-
-void __testcancel()
-{
-	pthread_t self = __pthread_self();
-	if (self->cancel && !self->canceldisable)
-		__cancel();
-}
-
-static void init_cancellation()
-{
-	struct sigaction sa = {
-		.sa_flags = SA_SIGINFO | SA_RESTART,
-		.sa_sigaction = cancel_handler
-	};
-	memset(&sa.sa_mask, -1, _NSIG/8);
-	__libc_sigaction(SIGCANCEL, &sa, 0);
-}
-
-int pthread_cancel(pthread_t t)
-{
-	static int init;
-	if (!init) {
-		init_cancellation();
-		init = 1;
-	}
-	a_store(&t->cancel, 1);
-	if (t == pthread_self() && !t->cancelasync) return 0;
-	return pthread_kill(t, SIGCANCEL);
-}
diff --git a/src/thread/pthread_cleanup_push.c b/src/thread/pthread_cleanup_push.c
deleted file mode 100644
index 9b21764b..00000000
--- a/src/thread/pthread_cleanup_push.c
+++ /dev/null
@@ -1,20 +0,0 @@
-#include "pthread_impl.h"
-
-static void dummy(struct __ptcb *cb)
-{
-}
-weak_alias(dummy, __do_cleanup_push);
-weak_alias(dummy, __do_cleanup_pop);
-
-void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x)
-{
-	cb->__f = f;
-	cb->__x = x;
-	__do_cleanup_push(cb);
-}
-
-void _pthread_cleanup_pop(struct __ptcb *cb, int run)
-{
-	__do_cleanup_pop(cb);
-	if (run) cb->__f(cb->__x);
-}
diff --git a/src/thread/pthread_cond_broadcast.c b/src/thread/pthread_cond_broadcast.c
deleted file mode 100644
index 69f840fb..00000000
--- a/src/thread/pthread_cond_broadcast.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include "pthread_impl.h"
-
-int __private_cond_signal(pthread_cond_t *, int);
-
-int pthread_cond_broadcast(pthread_cond_t *c)
-{
-	if (!c->_c_shared) return __private_cond_signal(c, -1);
-	if (!c->_c_waiters) return 0;
-	a_inc(&c->_c_seq);
-	__wake(&c->_c_seq, -1, 0);
-	return 0;
-}
diff --git a/src/thread/pthread_cond_destroy.c b/src/thread/pthread_cond_destroy.c
deleted file mode 100644
index 8c555160..00000000
--- a/src/thread/pthread_cond_destroy.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_cond_destroy(pthread_cond_t *c)
-{
-	if (c->_c_shared && c->_c_waiters) {
-		int cnt;
-		a_or(&c->_c_waiters, 0x80000000);
-		a_inc(&c->_c_seq);
-		__wake(&c->_c_seq, -1, 0);
-		while ((cnt = c->_c_waiters) & 0x7fffffff)
-			__wait(&c->_c_waiters, 0, cnt, 0);
-	}
-	return 0;
-}
diff --git a/src/thread/pthread_cond_init.c b/src/thread/pthread_cond_init.c
deleted file mode 100644
index 8c484ddc..00000000
--- a/src/thread/pthread_cond_init.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_cond_init(pthread_cond_t *restrict c, const pthread_condattr_t *restrict a)
-{
-	*c = (pthread_cond_t){0};
-	if (a) {
-		c->_c_clock = a->__attr & 0x7fffffff;
-		if (a->__attr>>31) c->_c_shared = (void *)-1;
-	}
-	return 0;
-}
diff --git a/src/thread/pthread_cond_signal.c b/src/thread/pthread_cond_signal.c
deleted file mode 100644
index 119c00ab..00000000
--- a/src/thread/pthread_cond_signal.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include "pthread_impl.h"
-
-int __private_cond_signal(pthread_cond_t *, int);
-
-int pthread_cond_signal(pthread_cond_t *c)
-{
-	if (!c->_c_shared) return __private_cond_signal(c, 1);
-	if (!c->_c_waiters) return 0;
-	a_inc(&c->_c_seq);
-	__wake(&c->_c_seq, 1, 0);
-	return 0;
-}
diff --git a/src/thread/pthread_cond_timedwait.c b/src/thread/pthread_cond_timedwait.c
deleted file mode 100644
index ed8569c2..00000000
--- a/src/thread/pthread_cond_timedwait.c
+++ /dev/null
@@ -1,214 +0,0 @@
-#include "pthread_impl.h"
-
-void __pthread_testcancel(void);
-int __pthread_mutex_lock(pthread_mutex_t *);
-int __pthread_mutex_unlock(pthread_mutex_t *);
-int __pthread_setcancelstate(int, int *);
-
-/*
- * struct waiter
- *
- * Waiter objects have automatic storage on the waiting thread, and
- * are used in building a linked list representing waiters currently
- * waiting on the condition variable or a group of waiters woken
- * together by a broadcast or signal; in the case of signal, this is a
- * degenerate list of one member.
- *
- * Waiter lists attached to the condition variable itself are
- * protected by the lock on the cv. Detached waiter lists are never
- * modified again, but can only be traversed in reverse order, and are
- * protected by the "barrier" locks in each node, which are unlocked
- * in turn to control wake order.
- *
- * Since process-shared cond var semantics do not necessarily allow
- * one thread to see another's automatic storage (they may be in
- * different processes), the waiter list is not used for the
- * process-shared case, but the structure is still used to store data
- * needed by the cancellation cleanup handler.
- */
-
-struct waiter {
-	struct waiter *prev, *next;
-	volatile int state, barrier;
-	volatile int *notify;
-};
-
-/* Self-synchronized-destruction-safe lock functions */
-
-static inline void lock(volatile int *l)
-{
-	if (a_cas(l, 0, 1)) {
-		a_cas(l, 1, 2);
-		do __wait(l, 0, 2, 1);
-		while (a_cas(l, 0, 2));
-	}
-}
-
-static inline void unlock(volatile int *l)
-{
-	if (a_swap(l, 0)==2)
-		__wake(l, 1, 1);
-}
-
-static inline void unlock_requeue(volatile int *l, volatile int *r, int w)
-{
-	a_store(l, 0);
-	if (w) __wake(l, 1, 1);
-	else __syscall(SYS_futex, l, FUTEX_REQUEUE|FUTEX_PRIVATE, 0, 1, r) != -ENOSYS
-		|| __syscall(SYS_futex, l, FUTEX_REQUEUE, 0, 1, r);
-}
-
-enum {
-	WAITING,
-	SIGNALED,
-	LEAVING,
-};
-
-int __pthread_cond_timedwait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m, const struct timespec *restrict ts)
-{
-	struct waiter node = { 0 };
-	int e, seq, clock = c->_c_clock, cs, shared=0, oldstate, tmp;
-	volatile int *fut;
-
-	if ((m->_m_type&15) && (m->_m_lock&INT_MAX) != __pthread_self()->tid)
-		return EPERM;
-
-	if (ts && ts->tv_nsec >= 1000000000UL)
-		return EINVAL;
-
-	__pthread_testcancel();
-
-	if (c->_c_shared) {
-		shared = 1;
-		fut = &c->_c_seq;
-		seq = c->_c_seq;
-		a_inc(&c->_c_waiters);
-	} else {
-		lock(&c->_c_lock);
-
-		seq = node.barrier = 2;
-		fut = &node.barrier;
-		node.state = WAITING;
-		node.next = c->_c_head;
-		c->_c_head = &node;
-		if (!c->_c_tail) c->_c_tail = &node;
-		else node.next->prev = &node;
-
-		unlock(&c->_c_lock);
-	}
-
-	__pthread_mutex_unlock(m);
-
-	__pthread_setcancelstate(PTHREAD_CANCEL_MASKED, &cs);
-	if (cs == PTHREAD_CANCEL_DISABLE) __pthread_setcancelstate(cs, 0);
-
-	do e = __timedwait_cp(fut, seq, clock, ts, !shared);
-	while (*fut==seq && (!e || e==EINTR));
-	if (e == EINTR) e = 0;
-
-	if (shared) {
-		/* Suppress cancellation if a signal was potentially
-		 * consumed; this is a legitimate form of spurious
-		 * wake even if not. */
-		if (e == ECANCELED && c->_c_seq != seq) e = 0;
-		if (a_fetch_add(&c->_c_waiters, -1) == -0x7fffffff)
-			__wake(&c->_c_waiters, 1, 0);
-		oldstate = WAITING;
-		goto relock;
-	}
-
-	oldstate = a_cas(&node.state, WAITING, LEAVING);
-
-	if (oldstate == WAITING) {
-		/* Access to cv object is valid because this waiter was not
-		 * yet signaled and a new signal/broadcast cannot return
-		 * after seeing a LEAVING waiter without getting notified
-		 * via the futex notify below. */
-
-		lock(&c->_c_lock);
-		
-		if (c->_c_head == &node) c->_c_head = node.next;
-		else if (node.prev) node.prev->next = node.next;
-		if (c->_c_tail == &node) c->_c_tail = node.prev;
-		else if (node.next) node.next->prev = node.prev;
-		
-		unlock(&c->_c_lock);
-
-		if (node.notify) {
-			if (a_fetch_add(node.notify, -1)==1)
-				__wake(node.notify, 1, 1);
-		}
-	} else {
-		/* Lock barrier first to control wake order. */
-		lock(&node.barrier);
-	}
-
-relock:
-	/* Errors locking the mutex override any existing error or
-	 * cancellation, since the caller must see them to know the
-	 * state of the mutex. */
-	if ((tmp = pthread_mutex_lock(m))) e = tmp;
-
-	if (oldstate == WAITING) goto done;
-
-	if (!node.next) a_inc(&m->_m_waiters);
-
-	/* Unlock the barrier that's holding back the next waiter, and
-	 * either wake it or requeue it to the mutex. */
-	if (node.prev)
-		unlock_requeue(&node.prev->barrier, &m->_m_lock, m->_m_type & 128);
-	else
-		a_dec(&m->_m_waiters);
-
-	/* Since a signal was consumed, cancellation is not permitted. */
-	if (e == ECANCELED) e = 0;
-
-done:
-	__pthread_setcancelstate(cs, 0);
-
-	if (e == ECANCELED) {
-		__pthread_testcancel();
-		__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);
-	}
-
-	return e;
-}
-
-int __private_cond_signal(pthread_cond_t *c, int n)
-{
-	struct waiter *p, *first=0;
-	volatile int ref = 0;
-	int cur;
-
-	lock(&c->_c_lock);
-	for (p=c->_c_tail; n && p; p=p->prev) {
-		if (a_cas(&p->state, WAITING, SIGNALED) != WAITING) {
-			ref++;
-			p->notify = &ref;
-		} else {
-			n--;
-			if (!first) first=p;
-		}
-	}
-	/* Split the list, leaving any remainder on the cv. */
-	if (p) {
-		if (p->next) p->next->prev = 0;
-		p->next = 0;
-	} else {
-		c->_c_head = 0;
-	}
-	c->_c_tail = p;
-	unlock(&c->_c_lock);
-
-	/* Wait for any waiters in the LEAVING state to remove
-	 * themselves from the list before returning or allowing
-	 * signaled threads to proceed. */
-	while ((cur = ref)) __wait(&ref, 0, cur, 1);
-
-	/* Allow first signaled waiter, if any, to proceed. */
-	if (first) unlock(&first->barrier);
-
-	return 0;
-}
-
-weak_alias(__pthread_cond_timedwait, pthread_cond_timedwait);
diff --git a/src/thread/pthread_cond_wait.c b/src/thread/pthread_cond_wait.c
deleted file mode 100644
index 8735bf14..00000000
--- a/src/thread/pthread_cond_wait.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_cond_wait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m)
-{
-	return pthread_cond_timedwait(c, m, 0);
-}
diff --git a/src/thread/pthread_condattr_destroy.c b/src/thread/pthread_condattr_destroy.c
deleted file mode 100644
index c54ec412..00000000
--- a/src/thread/pthread_condattr_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_condattr_destroy(pthread_condattr_t *a)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_condattr_init.c b/src/thread/pthread_condattr_init.c
deleted file mode 100644
index a41741b4..00000000
--- a/src/thread/pthread_condattr_init.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_condattr_init(pthread_condattr_t *a)
-{
-	*a = (pthread_condattr_t){0};
-	return 0;
-}
diff --git a/src/thread/pthread_condattr_setclock.c b/src/thread/pthread_condattr_setclock.c
deleted file mode 100644
index 71125941..00000000
--- a/src/thread/pthread_condattr_setclock.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_condattr_setclock(pthread_condattr_t *a, clockid_t clk)
-{
-	if (clk < 0 || clk-2U < 2) return EINVAL;
-	a->__attr &= 0x80000000;
-	a->__attr |= clk;
-	return 0;
-}
diff --git a/src/thread/pthread_condattr_setpshared.c b/src/thread/pthread_condattr_setpshared.c
deleted file mode 100644
index 51453e04..00000000
--- a/src/thread/pthread_condattr_setpshared.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_condattr_setpshared(pthread_condattr_t *a, int pshared)
-{
-	if (pshared > 1U) return EINVAL;
-	a->__attr &= 0x7fffffff;
-	a->__attr |= (unsigned)pshared<<31;
-	return 0;
-}
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
deleted file mode 100644
index 439ee363..00000000
--- a/src/thread/pthread_create.c
+++ /dev/null
@@ -1,317 +0,0 @@
-#define _GNU_SOURCE
-#include "pthread_impl.h"
-#include "stdio_impl.h"
-#include "libc.h"
-#include <sys/mman.h>
-#include <string.h>
-#include <stddef.h>
-
-void *__mmap(void *, size_t, int, int, int, off_t);
-int __munmap(void *, size_t);
-int __mprotect(void *, size_t, int);
-
-static void dummy_0()
-{
-}
-weak_alias(dummy_0, __acquire_ptc);
-weak_alias(dummy_0, __release_ptc);
-weak_alias(dummy_0, __pthread_tsd_run_dtors);
-weak_alias(dummy_0, __do_orphaned_stdio_locks);
-weak_alias(dummy_0, __dl_thread_cleanup);
-
-_Noreturn void __pthread_exit(void *result)
-{
-	pthread_t self = __pthread_self();
-	sigset_t set;
-
-	self->canceldisable = 1;
-	self->cancelasync = 0;
-	self->result = result;
-
-	while (self->cancelbuf) {
-		void (*f)(void *) = self->cancelbuf->__f;
-		void *x = self->cancelbuf->__x;
-		self->cancelbuf = self->cancelbuf->__next;
-		f(x);
-	}
-
-	__pthread_tsd_run_dtors();
-
-	LOCK(self->exitlock);
-
-	/* Mark this thread dead before decrementing count */
-	LOCK(self->killlock);
-	self->dead = 1;
-
-	/* Block all signals before decrementing the live thread count.
-	 * This is important to ensure that dynamically allocated TLS
-	 * is not under-allocated/over-committed, and possibly for other
-	 * reasons as well. */
-	__block_all_sigs(&set);
-
-	/* Wait to unlock the kill lock, which governs functions like
-	 * pthread_kill which target a thread id, until signals have
-	 * been blocked. This precludes observation of the thread id
-	 * as a live thread (with application code running in it) after
-	 * the thread was reported dead by ESRCH being returned. */
-	UNLOCK(self->killlock);
-
-	/* It's impossible to determine whether this is "the last thread"
-	 * until performing the atomic decrement, since multiple threads
-	 * could exit at the same time. For the last thread, revert the
-	 * decrement and unblock signals to give the atexit handlers and
-	 * stdio cleanup code a consistent state. */
-	if (a_fetch_add(&libc.threads_minus_1, -1)==0) {
-		libc.threads_minus_1 = 0;
-		__restore_sigs(&set);
-		exit(0);
-	}
-
-	/* Process robust list in userspace to handle non-pshared mutexes
-	 * and the detached thread case where the robust list head will
-	 * be invalid when the kernel would process it. */
-	__vm_lock();
-	volatile void *volatile *rp;
-	while ((rp=self->robust_list.head) && rp != &self->robust_list.head) {
-		pthread_mutex_t *m = (void *)((char *)rp
-			- offsetof(pthread_mutex_t, _m_next));
-		int waiters = m->_m_waiters;
-		int priv = (m->_m_type & 128) ^ 128;
-		self->robust_list.pending = rp;
-		self->robust_list.head = *rp;
-		int cont = a_swap(&m->_m_lock, 0x40000000);
-		self->robust_list.pending = 0;
-		if (cont < 0 || waiters)
-			__wake(&m->_m_lock, 1, priv);
-	}
-	__vm_unlock();
-
-	__do_orphaned_stdio_locks();
-	__dl_thread_cleanup();
-
-	if (self->detached && self->map_base) {
-		/* Detached threads must avoid the kernel clear_child_tid
-		 * feature, since the virtual address will have been
-		 * unmapped and possibly already reused by a new mapping
-		 * at the time the kernel would perform the write. In
-		 * the case of threads that started out detached, the
-		 * initial clone flags are correct, but if the thread was
-		 * detached later (== 2), we need to clear it here. */
-		if (self->detached == 2) __syscall(SYS_set_tid_address, 0);
-
-		/* Robust list will no longer be valid, and was already
-		 * processed above, so unregister it with the kernel. */
-		if (self->robust_list.off)
-			__syscall(SYS_set_robust_list, 0, 3*sizeof(long));
-
-		/* Since __unmapself bypasses the normal munmap code path,
-		 * explicitly wait for vmlock holders first. */
-		__vm_wait();
-
-		/* The following call unmaps the thread's stack mapping
-		 * and then exits without touching the stack. */
-		__unmapself(self->map_base, self->map_size);
-	}
-
-	for (;;) __syscall(SYS_exit, 0);
-}
-
-void __do_cleanup_push(struct __ptcb *cb)
-{
-	struct pthread *self = __pthread_self();
-	cb->__next = self->cancelbuf;
-	self->cancelbuf = cb;
-}
-
-void __do_cleanup_pop(struct __ptcb *cb)
-{
-	__pthread_self()->cancelbuf = cb->__next;
-}
-
-static int start(void *p)
-{
-	pthread_t self = p;
-	/* States for startlock:
-	 * 0 = no need for start sync
-	 * 1 = waiting for parent to do work
-	 * 2 = failure in parent, child must abort
-	 * 3 = success in parent, child must restore sigmask */
-	if (self->startlock[0]) {
-		__wait(self->startlock, 0, 1, 1);
-		if (self->startlock[0] == 2) {
-			self->detached = 2;
-			pthread_exit(0);
-		}
-		__restore_sigs(self->sigmask);
-	}
-	if (self->unblock_cancel)
-		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
-			SIGPT_SET, 0, _NSIG/8);
-	__pthread_exit(self->start(self->start_arg));
-	return 0;
-}
-
-static int start_c11(void *p)
-{
-	pthread_t self = p;
-	int (*start)(void*) = (int(*)(void*)) self->start;
-	__pthread_exit((void *)(uintptr_t)start(self->start_arg));
-	return 0;
-}
-
-#define ROUND(x) (((x)+PAGE_SIZE-1)&-PAGE_SIZE)
-
-/* pthread_key_create.c overrides this */
-static volatile size_t dummy = 0;
-weak_alias(dummy, __pthread_tsd_size);
-static void *dummy_tsd[1] = { 0 };
-weak_alias(dummy_tsd, __pthread_tsd_main);
-
-volatile int __block_new_threads = 0;
-size_t __default_stacksize = DEFAULT_STACK_SIZE;
-size_t __default_guardsize = DEFAULT_GUARD_SIZE;
-
-static FILE *volatile dummy_file = 0;
-weak_alias(dummy_file, __stdin_used);
-weak_alias(dummy_file, __stdout_used);
-weak_alias(dummy_file, __stderr_used);
-
-static void init_file_lock(FILE *f)
-{
-	if (f && f->lock<0) f->lock = 0;
-}
-
-void *__copy_tls(unsigned char *);
-
-int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg)
-{
-	int ret, c11 = (attrp == __ATTRP_C11_THREAD);
-	size_t size, guard;
-	struct pthread *self, *new;
-	unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit;
-	unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
-		| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS
-		| CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED;
-	int do_sched = 0;
-	pthread_attr_t attr = { 0 };
-
-	if (!libc.can_do_threads) return ENOSYS;
-	self = __pthread_self();
-	if (!libc.threaded) {
-		for (FILE *f=*__ofl_lock(); f; f=f->next)
-			init_file_lock(f);
-		__ofl_unlock();
-		init_file_lock(__stdin_used);
-		init_file_lock(__stdout_used);
-		init_file_lock(__stderr_used);
-		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, SIGPT_SET, 0, _NSIG/8);
-		self->tsd = (void **)__pthread_tsd_main;
-		libc.threaded = 1;
-	}
-	if (attrp && !c11) attr = *attrp;
-
-	__acquire_ptc();
-	if (!attrp || c11) {
-		attr._a_stacksize = __default_stacksize;
-		attr._a_guardsize = __default_guardsize;
-	}
-
-	if (__block_new_threads) __wait(&__block_new_threads, 0, 1, 1);
-
-	if (attr._a_stackaddr) {
-		size_t need = libc.tls_size + __pthread_tsd_size;
-		size = attr._a_stacksize;
-		stack = (void *)(attr._a_stackaddr & -16);
-		stack_limit = (void *)(attr._a_stackaddr - size);
-		/* Use application-provided stack for TLS only when
-		 * it does not take more than ~12% or 2k of the
-		 * application's stack space. */
-		if (need < size/8 && need < 2048) {
-			tsd = stack - __pthread_tsd_size;
-			stack = tsd - libc.tls_size;
-			memset(stack, 0, need);
-		} else {
-			size = ROUND(need);
-		}
-		guard = 0;
-	} else {
-		guard = ROUND(attr._a_guardsize);
-		size = guard + ROUND(attr._a_stacksize
-			+ libc.tls_size +  __pthread_tsd_size);
-	}
-
-	if (!tsd) {
-		if (guard) {
-			map = __mmap(0, size, PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
-			if (__mprotect(map+guard, size-guard, PROT_READ|PROT_WRITE)
-			    && errno != ENOSYS) {
-				__munmap(map, size);
-				goto fail;
-			}
-		} else {
-			map = __mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
-		}
-		tsd = map + size - __pthread_tsd_size;
-		if (!stack) {
-			stack = tsd - libc.tls_size;
-			stack_limit = map + guard;
-		}
-	}
-
-	new = __copy_tls(tsd - libc.tls_size);
-	new->map_base = map;
-	new->map_size = size;
-	new->stack = stack;
-	new->stack_size = stack - stack_limit;
-	new->guard_size = guard;
-	new->start = entry;
-	new->start_arg = arg;
-	new->self = new;
-	new->tsd = (void *)tsd;
-	new->locale = &libc.global_locale;
-	if (attr._a_detach) {
-		new->detached = 1;
-		flags -= CLONE_CHILD_CLEARTID;
-	}
-	if (attr._a_sched) {
-		do_sched = new->startlock[0] = 1;
-		__block_app_sigs(new->sigmask);
-	}
-	new->robust_list.head = &new->robust_list.head;
-	new->unblock_cancel = self->cancel;
-	new->CANARY = self->CANARY;
-
-	a_inc(&libc.threads_minus_1);
-	ret = __clone((c11 ? start_c11 : start), stack, flags, new, &new->tid, TP_ADJ(new), &new->tid);
-
-	__release_ptc();
-
-	if (do_sched) {
-		__restore_sigs(new->sigmask);
-	}
-
-	if (ret < 0) {
-		a_dec(&libc.threads_minus_1);
-		if (map) __munmap(map, size);
-		return EAGAIN;
-	}
-
-	if (do_sched) {
-		ret = __syscall(SYS_sched_setscheduler, new->tid,
-			attr._a_policy, &attr._a_prio);
-		a_store(new->startlock, ret<0 ? 2 : 3);
-		__wake(new->startlock, 1, 1);
-		if (ret < 0) return -ret;
-	}
-
-	*res = new;
-	return 0;
-fail:
-	__release_ptc();
-	return EAGAIN;
-}
-
-weak_alias(__pthread_exit, pthread_exit);
-weak_alias(__pthread_create, pthread_create);
diff --git a/src/thread/pthread_detach.c b/src/thread/pthread_detach.c
deleted file mode 100644
index 692bbaf9..00000000
--- a/src/thread/pthread_detach.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include "pthread_impl.h"
-#include <threads.h>
-
-int __pthread_join(pthread_t, void **);
-
-static int __pthread_detach(pthread_t t)
-{
-	/* Cannot detach a thread that's already exiting */
-	if (a_cas(t->exitlock, 0, INT_MIN + 1))
-		return __pthread_join(t, 0);
-	t->detached = 2;
-	UNLOCK(t->exitlock);
-	return 0;
-}
-
-weak_alias(__pthread_detach, pthread_detach);
-weak_alias(__pthread_detach, thrd_detach);
diff --git a/src/thread/pthread_equal.c b/src/thread/pthread_equal.c
deleted file mode 100644
index 7c31482a..00000000
--- a/src/thread/pthread_equal.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include <pthread.h>
-#include <threads.h>
-#include "libc.h"
-
-static int __pthread_equal(pthread_t a, pthread_t b)
-{
-	return a==b;
-}
-
-weak_alias(__pthread_equal, pthread_equal);
-weak_alias(__pthread_equal, thrd_equal);
diff --git a/src/thread/pthread_getattr_np.c b/src/thread/pthread_getattr_np.c
deleted file mode 100644
index 29a209bd..00000000
--- a/src/thread/pthread_getattr_np.c
+++ /dev/null
@@ -1,24 +0,0 @@
-#define _GNU_SOURCE
-#include "pthread_impl.h"
-#include "libc.h"
-#include <sys/mman.h>
-
-int pthread_getattr_np(pthread_t t, pthread_attr_t *a)
-{
-	*a = (pthread_attr_t){0};
-	a->_a_detach = !!t->detached;
-	a->_a_guardsize = t->guard_size;
-	if (t->stack) {
-		a->_a_stackaddr = (uintptr_t)t->stack;
-		a->_a_stacksize = t->stack_size;
-	} else {
-		char *p = (void *)libc.auxv;
-		size_t l = PAGE_SIZE;
-		p += -(uintptr_t)p & PAGE_SIZE-1;
-		a->_a_stackaddr = (uintptr_t)p;
-		while (mremap(p-l-PAGE_SIZE, PAGE_SIZE, 2*PAGE_SIZE, 0)==MAP_FAILED && errno==ENOMEM)
-			l += PAGE_SIZE;
-		a->_a_stacksize = l;
-	}
-	return 0;
-}
diff --git a/src/thread/pthread_getconcurrency.c b/src/thread/pthread_getconcurrency.c
deleted file mode 100644
index 269429a8..00000000
--- a/src/thread/pthread_getconcurrency.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <pthread.h>
-
-int pthread_getconcurrency()
-{
-	return 0;
-}
diff --git a/src/thread/pthread_getcpuclockid.c b/src/thread/pthread_getcpuclockid.c
deleted file mode 100644
index 9df14fb6..00000000
--- a/src/thread/pthread_getcpuclockid.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_getcpuclockid(pthread_t t, clockid_t *clockid)
-{
-	*clockid = (-t->tid-1)*8U + 6;
-	return 0;
-}
diff --git a/src/thread/pthread_getschedparam.c b/src/thread/pthread_getschedparam.c
deleted file mode 100644
index a994b637..00000000
--- a/src/thread/pthread_getschedparam.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param)
-{
-	int r;
-	LOCK(t->killlock);
-	if (t->dead) {
-		r = ESRCH;
-	} else {
-		r = -__syscall(SYS_sched_getparam, t->tid, param);
-		if (!r) {
-			*policy = __syscall(SYS_sched_getscheduler, t->tid);
-		}
-	}
-	UNLOCK(t->killlock);
-	return r;
-}
diff --git a/src/thread/pthread_getspecific.c b/src/thread/pthread_getspecific.c
deleted file mode 100644
index d9342a56..00000000
--- a/src/thread/pthread_getspecific.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include "pthread_impl.h"
-#include <threads.h>
-
-static void *__pthread_getspecific(pthread_key_t k)
-{
-	struct pthread *self = __pthread_self();
-	return self->tsd[k];
-}
-
-weak_alias(__pthread_getspecific, pthread_getspecific);
-weak_alias(__pthread_getspecific, tss_get);
diff --git a/src/thread/pthread_join.c b/src/thread/pthread_join.c
deleted file mode 100644
index b7175c09..00000000
--- a/src/thread/pthread_join.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include "pthread_impl.h"
-#include <sys/mman.h>
-
-int __munmap(void *, size_t);
-void __pthread_testcancel(void);
-int __pthread_setcancelstate(int, int *);
-
-int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at)
-{
-	int tmp, cs, r = 0;
-	__pthread_testcancel();
-	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-	if (cs == PTHREAD_CANCEL_ENABLE) __pthread_setcancelstate(cs, 0);
-	if (t->detached) a_crash();
-	while ((tmp = t->tid) && r != ETIMEDOUT && r != EINVAL)
-		r = __timedwait_cp(&t->tid, tmp, CLOCK_REALTIME, at, 0);
-	__pthread_setcancelstate(cs, 0);
-	if (r == ETIMEDOUT || r == EINVAL) return r;
-	a_barrier();
-	if (res) *res = t->result;
-	if (t->map_base) __munmap(t->map_base, t->map_size);
-	return 0;
-}
-
-int __pthread_join(pthread_t t, void **res)
-{
-	return __pthread_timedjoin_np(t, res, 0);
-}
-
-int __pthread_tryjoin_np(pthread_t t, void **res)
-{
-	return t->tid ? EBUSY : __pthread_join(t, res);
-}
-
-weak_alias(__pthread_tryjoin_np, pthread_tryjoin_np);
-weak_alias(__pthread_timedjoin_np, pthread_timedjoin_np);
-weak_alias(__pthread_join, pthread_join);
diff --git a/src/thread/pthread_key_create.c b/src/thread/pthread_key_create.c
deleted file mode 100644
index a78e507a..00000000
--- a/src/thread/pthread_key_create.c
+++ /dev/null
@@ -1,56 +0,0 @@
-#include "pthread_impl.h"
-
-volatile size_t __pthread_tsd_size = sizeof(void *) * PTHREAD_KEYS_MAX;
-void *__pthread_tsd_main[PTHREAD_KEYS_MAX] = { 0 };
-
-static void (*volatile keys[PTHREAD_KEYS_MAX])(void *);
-
-static void nodtor(void *dummy)
-{
-}
-
-int __pthread_key_create(pthread_key_t *k, void (*dtor)(void *))
-{
-	unsigned i = (uintptr_t)&k / 16 % PTHREAD_KEYS_MAX;
-	unsigned j = i;
-	pthread_t self = __pthread_self();
-
-	/* This can only happen in the main thread before
-	 * pthread_create has been called. */
-	if (!self->tsd) self->tsd = __pthread_tsd_main;
-
-	if (!dtor) dtor = nodtor;
-	do {
-		if (!a_cas_p(keys+j, 0, (void *)dtor)) {
-			*k = j;
-			return 0;
-		}
-	} while ((j=(j+1)%PTHREAD_KEYS_MAX) != i);
-	return EAGAIN;
-}
-
-int __pthread_key_delete(pthread_key_t k)
-{
-	keys[k] = 0;
-	return 0;
-}
-
-void __pthread_tsd_run_dtors()
-{
-	pthread_t self = __pthread_self();
-	int i, j, not_finished = self->tsd_used;
-	for (j=0; not_finished && j<PTHREAD_DESTRUCTOR_ITERATIONS; j++) {
-		not_finished = 0;
-		for (i=0; i<PTHREAD_KEYS_MAX; i++) {
-			if (self->tsd[i] && keys[i]) {
-				void *tmp = self->tsd[i];
-				self->tsd[i] = 0;
-				keys[i](tmp);
-				not_finished = 1;
-			}
-		}
-	}
-}
-
-weak_alias(__pthread_key_delete, pthread_key_delete);
-weak_alias(__pthread_key_create, pthread_key_create);
diff --git a/src/thread/pthread_kill.c b/src/thread/pthread_kill.c
deleted file mode 100644
index f0903420..00000000
--- a/src/thread/pthread_kill.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_kill(pthread_t t, int sig)
-{
-	int r;
-	LOCK(t->killlock);
-	r = t->dead ? ESRCH : -__syscall(SYS_tkill, t->tid, sig);
-	UNLOCK(t->killlock);
-	return r;
-}
diff --git a/src/thread/pthread_mutex_consistent.c b/src/thread/pthread_mutex_consistent.c
deleted file mode 100644
index 96b83b52..00000000
--- a/src/thread/pthread_mutex_consistent.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutex_consistent(pthread_mutex_t *m)
-{
-	if (!(m->_m_type & 8)) return EINVAL;
-	if ((m->_m_lock & 0x7fffffff) != __pthread_self()->tid)
-		return EPERM;
-	m->_m_type &= ~8U;
-	return 0;
-}
diff --git a/src/thread/pthread_mutex_destroy.c b/src/thread/pthread_mutex_destroy.c
deleted file mode 100644
index 6d49e689..00000000
--- a/src/thread/pthread_mutex_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <pthread.h>
-
-int pthread_mutex_destroy(pthread_mutex_t *mutex)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_mutex_getprioceiling.c b/src/thread/pthread_mutex_getprioceiling.c
deleted file mode 100644
index 8c75a661..00000000
--- a/src/thread/pthread_mutex_getprioceiling.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict m, int *restrict ceiling)
-{
-	return EINVAL;
-}
diff --git a/src/thread/pthread_mutex_init.c b/src/thread/pthread_mutex_init.c
deleted file mode 100644
index acf45a74..00000000
--- a/src/thread/pthread_mutex_init.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a)
-{
-	*m = (pthread_mutex_t){0};
-	if (a) m->_m_type = a->__attr;
-	return 0;
-}
diff --git a/src/thread/pthread_mutex_lock.c b/src/thread/pthread_mutex_lock.c
deleted file mode 100644
index d0c93cab..00000000
--- a/src/thread/pthread_mutex_lock.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include "pthread_impl.h"
-
-int __pthread_mutex_timedlock(pthread_mutex_t *restrict, const struct timespec *restrict);
-
-int __pthread_mutex_lock(pthread_mutex_t *m)
-{
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
-	    && !a_cas(&m->_m_lock, 0, EBUSY))
-		return 0;
-
-	return __pthread_mutex_timedlock(m, 0);
-}
-
-weak_alias(__pthread_mutex_lock, pthread_mutex_lock);
diff --git a/src/thread/pthread_mutex_setprioceiling.c b/src/thread/pthread_mutex_setprioceiling.c
deleted file mode 100644
index 681f07c8..00000000
--- a/src/thread/pthread_mutex_setprioceiling.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutex_setprioceiling(pthread_mutex_t *restrict m, int ceiling, int *restrict old)
-{
-	return EINVAL;
-}
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
deleted file mode 100644
index 0a240e79..00000000
--- a/src/thread/pthread_mutex_timedlock.c
+++ /dev/null
@@ -1,34 +0,0 @@
-#include "pthread_impl.h"
-
-int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
-{
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
-	    && !a_cas(&m->_m_lock, 0, EBUSY))
-		return 0;
-
-	int r, t, priv = (m->_m_type & 128) ^ 128;
-
-	r = pthread_mutex_trylock(m);
-	if (r != EBUSY) return r;
-	
-	int spins = 100;
-	while (spins-- && m->_m_lock && !m->_m_waiters) a_spin();
-
-	while ((r=pthread_mutex_trylock(m)) == EBUSY) {
-		if (!(r=m->_m_lock) || ((r&0x40000000) && (m->_m_type&4)))
-			continue;
-		if ((m->_m_type&3) == PTHREAD_MUTEX_ERRORCHECK
-		 && (r&0x7fffffff) == __pthread_self()->tid)
-			return EDEADLK;
-
-		a_inc(&m->_m_waiters);
-		t = r | 0x80000000;
-		a_cas(&m->_m_lock, r, t);
-		r = __timedwait(&m->_m_lock, t, CLOCK_REALTIME, at, priv);
-		a_dec(&m->_m_waiters);
-		if (r && r != EINTR) break;
-	}
-	return r;
-}
-
-weak_alias(__pthread_mutex_timedlock, pthread_mutex_timedlock);
diff --git a/src/thread/pthread_mutex_trylock.c b/src/thread/pthread_mutex_trylock.c
deleted file mode 100644
index 54876a61..00000000
--- a/src/thread/pthread_mutex_trylock.c
+++ /dev/null
@@ -1,58 +0,0 @@
-#include "pthread_impl.h"
-
-int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
-{
-	int old, own;
-	int type = m->_m_type & 15;
-	pthread_t self = __pthread_self();
-	int tid = self->tid;
-
-	old = m->_m_lock;
-	own = old & 0x7fffffff;
-	if (own == tid && (type&3) == PTHREAD_MUTEX_RECURSIVE) {
-		if ((unsigned)m->_m_count >= INT_MAX) return EAGAIN;
-		m->_m_count++;
-		return 0;
-	}
-	if (own == 0x7fffffff) return ENOTRECOVERABLE;
-
-	if (m->_m_type & 128) {
-		if (!self->robust_list.off) {
-			self->robust_list.off = (char*)&m->_m_lock-(char *)&m->_m_next;
-			__syscall(SYS_set_robust_list, &self->robust_list, 3*sizeof(long));
-		}
-		if (m->_m_waiters) tid |= 0x80000000;
-		self->robust_list.pending = &m->_m_next;
-	}
-
-	if ((own && (!(own & 0x40000000) || !(type & 4)))
-	    || a_cas(&m->_m_lock, old, tid) != old) {
-		self->robust_list.pending = 0;
-		return EBUSY;
-	}
-
-	volatile void *next = self->robust_list.head;
-	m->_m_next = next;
-	m->_m_prev = &self->robust_list.head;
-	if (next != &self->robust_list.head) *(volatile void *volatile *)
-		((char *)next - sizeof(void *)) = &m->_m_next;
-	self->robust_list.head = &m->_m_next;
-	self->robust_list.pending = 0;
-
-	if (own) {
-		m->_m_count = 0;
-		m->_m_type |= 8;
-		return EOWNERDEAD;
-	}
-
-	return 0;
-}
-
-int __pthread_mutex_trylock(pthread_mutex_t *m)
-{
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL)
-		return a_cas(&m->_m_lock, 0, EBUSY) & EBUSY;
-	return __pthread_mutex_trylock_owner(m);
-}
-
-weak_alias(__pthread_mutex_trylock, pthread_mutex_trylock);
diff --git a/src/thread/pthread_mutex_unlock.c b/src/thread/pthread_mutex_unlock.c
deleted file mode 100644
index 7dd00d27..00000000
--- a/src/thread/pthread_mutex_unlock.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include "pthread_impl.h"
-
-int __pthread_mutex_unlock(pthread_mutex_t *m)
-{
-	pthread_t self;
-	int waiters = m->_m_waiters;
-	int cont;
-	int type = m->_m_type & 15;
-	int priv = (m->_m_type & 128) ^ 128;
-
-	if (type != PTHREAD_MUTEX_NORMAL) {
-		self = __pthread_self();
-		if ((m->_m_lock&0x7fffffff) != self->tid)
-			return EPERM;
-		if ((type&3) == PTHREAD_MUTEX_RECURSIVE && m->_m_count)
-			return m->_m_count--, 0;
-		if (!priv) {
-			self->robust_list.pending = &m->_m_next;
-			__vm_lock();
-		}
-		volatile void *prev = m->_m_prev;
-		volatile void *next = m->_m_next;
-		*(volatile void *volatile *)prev = next;
-		if (next != &self->robust_list.head) *(volatile void *volatile *)
-			((char *)next - sizeof(void *)) = prev;
-	}
-	cont = a_swap(&m->_m_lock, (type & 8) ? 0x7fffffff : 0);
-	if (type != PTHREAD_MUTEX_NORMAL && !priv) {
-		self->robust_list.pending = 0;
-		__vm_unlock();
-	}
-	if (waiters || cont<0)
-		__wake(&m->_m_lock, 1, priv);
-	return 0;
-}
-
-weak_alias(__pthread_mutex_unlock, pthread_mutex_unlock);
diff --git a/src/thread/pthread_mutexattr_destroy.c b/src/thread/pthread_mutexattr_destroy.c
deleted file mode 100644
index 9fd69747..00000000
--- a/src/thread/pthread_mutexattr_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_destroy(pthread_mutexattr_t *a)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_mutexattr_init.c b/src/thread/pthread_mutexattr_init.c
deleted file mode 100644
index 0b72c1ba..00000000
--- a/src/thread/pthread_mutexattr_init.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_init(pthread_mutexattr_t *a)
-{
-	*a = (pthread_mutexattr_t){0};
-	return 0;
-}
diff --git a/src/thread/pthread_mutexattr_setprotocol.c b/src/thread/pthread_mutexattr_setprotocol.c
deleted file mode 100644
index c92a31c8..00000000
--- a/src/thread/pthread_mutexattr_setprotocol.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int protocol)
-{
-	if (protocol) return ENOTSUP;
-	return 0;
-}
diff --git a/src/thread/pthread_mutexattr_setpshared.c b/src/thread/pthread_mutexattr_setpshared.c
deleted file mode 100644
index 100f6ff2..00000000
--- a/src/thread/pthread_mutexattr_setpshared.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_setpshared(pthread_mutexattr_t *a, int pshared)
-{
-	if (pshared > 1U) return EINVAL;
-	a->__attr &= ~128U;
-	a->__attr |= pshared<<7;
-	return 0;
-}
diff --git a/src/thread/pthread_mutexattr_setrobust.c b/src/thread/pthread_mutexattr_setrobust.c
deleted file mode 100644
index dcfa4cf1..00000000
--- a/src/thread/pthread_mutexattr_setrobust.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_setrobust(pthread_mutexattr_t *a, int robust)
-{
-	if (robust > 1U) return EINVAL;
-	a->__attr &= ~4;
-	a->__attr |= robust*4;
-	return 0;
-}
diff --git a/src/thread/pthread_mutexattr_settype.c b/src/thread/pthread_mutexattr_settype.c
deleted file mode 100644
index cd7a80e3..00000000
--- a/src/thread/pthread_mutexattr_settype.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type)
-{
-	if ((unsigned)type > 2) return EINVAL;
-	a->__attr = (a->__attr & ~3) | type;
-	return 0;
-}
diff --git a/src/thread/pthread_once.c b/src/thread/pthread_once.c
deleted file mode 100644
index a8f8aeb1..00000000
--- a/src/thread/pthread_once.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include "pthread_impl.h"
-
-static void undo(void *control)
-{
-	/* Wake all waiters, since the waiter status is lost when
-	 * resetting control to the initial state. */
-	if (a_swap(control, 0) == 3)
-		__wake(control, -1, 1);
-}
-
-int __pthread_once_full(pthread_once_t *control, void (*init)(void))
-{
-	/* Try to enter initializing state. Four possibilities:
-	 *  0 - we're the first or the other cancelled; run init
-	 *  1 - another thread is running init; wait
-	 *  2 - another thread finished running init; just return
-	 *  3 - another thread is running init, waiters present; wait */
-
-	for (;;) switch (a_cas(control, 0, 1)) {
-	case 0:
-		pthread_cleanup_push(undo, control);
-		init();
-		pthread_cleanup_pop(0);
-
-		if (a_swap(control, 2) == 3)
-			__wake(control, -1, 1);
-		return 0;
-	case 1:
-		/* If this fails, so will __wait. */
-		a_cas(control, 1, 3);
-	case 3:
-		__wait(control, 0, 3, 1);
-		continue;
-	case 2:
-		return 0;
-	}
-}
-
-int __pthread_once(pthread_once_t *control, void (*init)(void))
-{
-	/* Return immediately if init finished before, but ensure that
-	 * effects of the init routine are visible to the caller. */
-	if (*(volatile int *)control == 2) {
-		a_barrier();
-		return 0;
-	}
-	return __pthread_once_full(control, init);
-}
-
-weak_alias(__pthread_once, pthread_once);
diff --git a/src/thread/pthread_rwlock_destroy.c b/src/thread/pthread_rwlock_destroy.c
deleted file mode 100644
index 49ecfbd0..00000000
--- a/src/thread/pthread_rwlock_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_destroy(pthread_rwlock_t *rw)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_rwlock_init.c b/src/thread/pthread_rwlock_init.c
deleted file mode 100644
index a2c0b478..00000000
--- a/src/thread/pthread_rwlock_init.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_init(pthread_rwlock_t *restrict rw, const pthread_rwlockattr_t *restrict a)
-{
-	*rw = (pthread_rwlock_t){0};
-	if (a) rw->_rw_shared = a->__attr[0]*128;
-	return 0;
-}
diff --git a/src/thread/pthread_rwlock_rdlock.c b/src/thread/pthread_rwlock_rdlock.c
deleted file mode 100644
index 0800d21f..00000000
--- a/src/thread/pthread_rwlock_rdlock.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_rdlock(pthread_rwlock_t *rw)
-{
-	return pthread_rwlock_timedrdlock(rw, 0);
-}
diff --git a/src/thread/pthread_rwlock_timedrdlock.c b/src/thread/pthread_rwlock_timedrdlock.c
deleted file mode 100644
index 0d5d0d6c..00000000
--- a/src/thread/pthread_rwlock_timedrdlock.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rw, const struct timespec *restrict at)
-{
-	int r, t;
-
-	r = pthread_rwlock_tryrdlock(rw);
-	if (r != EBUSY) return r;
-	
-	int spins = 100;
-	while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
-
-	while ((r=pthread_rwlock_tryrdlock(rw))==EBUSY) {
-		if (!(r=rw->_rw_lock) || (r&0x7fffffff)!=0x7fffffff) continue;
-		t = r | 0x80000000;
-		a_inc(&rw->_rw_waiters);
-		a_cas(&rw->_rw_lock, r, t);
-		r = __timedwait(&rw->_rw_lock, t, CLOCK_REALTIME, at, rw->_rw_shared^128);
-		a_dec(&rw->_rw_waiters);
-		if (r && r != EINTR) return r;
-	}
-	return r;
-}
diff --git a/src/thread/pthread_rwlock_timedwrlock.c b/src/thread/pthread_rwlock_timedwrlock.c
deleted file mode 100644
index 7f26dad1..00000000
--- a/src/thread/pthread_rwlock_timedwrlock.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rw, const struct timespec *restrict at)
-{
-	int r, t;
-	
-	r = pthread_rwlock_trywrlock(rw);
-	if (r != EBUSY) return r;
-	
-	int spins = 100;
-	while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
-
-	while ((r=pthread_rwlock_trywrlock(rw))==EBUSY) {
-		if (!(r=rw->_rw_lock)) continue;
-		t = r | 0x80000000;
-		a_inc(&rw->_rw_waiters);
-		a_cas(&rw->_rw_lock, r, t);
-		r = __timedwait(&rw->_rw_lock, t, CLOCK_REALTIME, at, rw->_rw_shared^128);
-		a_dec(&rw->_rw_waiters);
-		if (r && r != EINTR) return r;
-	}
-	return r;
-}
diff --git a/src/thread/pthread_rwlock_tryrdlock.c b/src/thread/pthread_rwlock_tryrdlock.c
deleted file mode 100644
index fa271fcc..00000000
--- a/src/thread/pthread_rwlock_tryrdlock.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_tryrdlock(pthread_rwlock_t *rw)
-{
-	int val, cnt;
-	do {
-		val = rw->_rw_lock;
-		cnt = val & 0x7fffffff;
-		if (cnt == 0x7fffffff) return EBUSY;
-		if (cnt == 0x7ffffffe) return EAGAIN;
-	} while (a_cas(&rw->_rw_lock, val, val+1) != val);
-	return 0;
-}
diff --git a/src/thread/pthread_rwlock_trywrlock.c b/src/thread/pthread_rwlock_trywrlock.c
deleted file mode 100644
index bb3d3a99..00000000
--- a/src/thread/pthread_rwlock_trywrlock.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_trywrlock(pthread_rwlock_t *rw)
-{
-	if (a_cas(&rw->_rw_lock, 0, 0x7fffffff)) return EBUSY;
-	return 0;
-}
diff --git a/src/thread/pthread_rwlock_unlock.c b/src/thread/pthread_rwlock_unlock.c
deleted file mode 100644
index 7b5eec84..00000000
--- a/src/thread/pthread_rwlock_unlock.c
+++ /dev/null
@@ -1,18 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_unlock(pthread_rwlock_t *rw)
-{
-	int val, cnt, waiters, new, priv = rw->_rw_shared^128;
-
-	do {
-		val = rw->_rw_lock;
-		cnt = val & 0x7fffffff;
-		waiters = rw->_rw_waiters;
-		new = (cnt == 0x7fffffff || cnt == 1) ? 0 : val-1;
-	} while (a_cas(&rw->_rw_lock, val, new) != val);
-
-	if (!new && (waiters || val<0))
-		__wake(&rw->_rw_lock, cnt, priv);
-
-	return 0;
-}
diff --git a/src/thread/pthread_rwlock_wrlock.c b/src/thread/pthread_rwlock_wrlock.c
deleted file mode 100644
index 7f33535c..00000000
--- a/src/thread/pthread_rwlock_wrlock.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlock_wrlock(pthread_rwlock_t *rw)
-{
-	return pthread_rwlock_timedwrlock(rw, 0);
-}
diff --git a/src/thread/pthread_rwlockattr_destroy.c b/src/thread/pthread_rwlockattr_destroy.c
deleted file mode 100644
index fc8d611a..00000000
--- a/src/thread/pthread_rwlockattr_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_rwlockattr_init.c b/src/thread/pthread_rwlockattr_init.c
deleted file mode 100644
index e7420694..00000000
--- a/src/thread/pthread_rwlockattr_init.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlockattr_init(pthread_rwlockattr_t *a)
-{
-	*a = (pthread_rwlockattr_t){0};
-	return 0;
-}
diff --git a/src/thread/pthread_rwlockattr_setpshared.c b/src/thread/pthread_rwlockattr_setpshared.c
deleted file mode 100644
index e7061973..00000000
--- a/src/thread/pthread_rwlockattr_setpshared.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int pshared)
-{
-	if (pshared > 1U) return EINVAL;
-	a->__attr[0] = pshared;
-	return 0;
-}
diff --git a/src/thread/pthread_self.c b/src/thread/pthread_self.c
deleted file mode 100644
index 241a6202..00000000
--- a/src/thread/pthread_self.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include "pthread_impl.h"
-#include <threads.h>
-#include "libc.h"
-
-static pthread_t __pthread_self_internal()
-{
-	return __pthread_self();
-}
-
-weak_alias(__pthread_self_internal, pthread_self);
-weak_alias(__pthread_self_internal, thrd_current);
diff --git a/src/thread/pthread_setattr_default_np.c b/src/thread/pthread_setattr_default_np.c
deleted file mode 100644
index ffd2712b..00000000
--- a/src/thread/pthread_setattr_default_np.c
+++ /dev/null
@@ -1,35 +0,0 @@
-#include "pthread_impl.h"
-#include <string.h>
-
-extern size_t __default_stacksize;
-extern size_t __default_guardsize;
-
-int pthread_setattr_default_np(const pthread_attr_t *attrp)
-{
-	/* Reject anything in the attr object other than stack/guard size. */
-	pthread_attr_t tmp = *attrp, zero = { 0 };
-	tmp._a_stacksize = 0;
-	tmp._a_guardsize = 0;
-	if (memcmp(&tmp, &zero, sizeof tmp))
-		return EINVAL;
-
-	__inhibit_ptc();
-	if (attrp->_a_stacksize >= __default_stacksize)
-		__default_stacksize = attrp->_a_stacksize;
-	if (attrp->_a_guardsize >= __default_guardsize)
-		__default_guardsize = attrp->_a_guardsize;
-	__release_ptc();
-
-	return 0;
-}
-
-int pthread_getattr_default_np(pthread_attr_t *attrp)
-{
-	__acquire_ptc();
-	*attrp = (pthread_attr_t) {
-		._a_stacksize = __default_stacksize,
-		._a_guardsize = __default_guardsize,
-	};
-	__release_ptc();
-	return 0;
-}
diff --git a/src/thread/pthread_setcancelstate.c b/src/thread/pthread_setcancelstate.c
deleted file mode 100644
index 5ab8c338..00000000
--- a/src/thread/pthread_setcancelstate.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include "pthread_impl.h"
-
-int __pthread_setcancelstate(int new, int *old)
-{
-	if (new > 2U) return EINVAL;
-	struct pthread *self = __pthread_self();
-	if (old) *old = self->canceldisable;
-	self->canceldisable = new;
-	return 0;
-}
-
-weak_alias(__pthread_setcancelstate, pthread_setcancelstate);
diff --git a/src/thread/pthread_setcanceltype.c b/src/thread/pthread_setcanceltype.c
deleted file mode 100644
index bf0a3f38..00000000
--- a/src/thread/pthread_setcanceltype.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_setcanceltype(int new, int *old)
-{
-	struct pthread *self = __pthread_self();
-	if (new > 1U) return EINVAL;
-	if (old) *old = self->cancelasync;
-	self->cancelasync = new;
-	if (new) pthread_testcancel();
-	return 0;
-}
diff --git a/src/thread/pthread_setconcurrency.c b/src/thread/pthread_setconcurrency.c
deleted file mode 100644
index 091abf98..00000000
--- a/src/thread/pthread_setconcurrency.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <pthread.h>
-#include <errno.h>
-
-int pthread_setconcurrency(int val)
-{
-	if (val < 0) return EINVAL;
-	if (val > 0) return EAGAIN;
-	return 0;
-}
diff --git a/src/thread/pthread_setname_np.c b/src/thread/pthread_setname_np.c
deleted file mode 100644
index 82d35e17..00000000
--- a/src/thread/pthread_setname_np.c
+++ /dev/null
@@ -1,26 +0,0 @@
-#define _GNU_SOURCE
-#include <fcntl.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/prctl.h>
-
-#include "pthread_impl.h"
-
-int pthread_setname_np(pthread_t thread, const char *name)
-{
-	int fd, cs, status = 0;
-	char f[sizeof "/proc/self/task//comm" + 3*sizeof(int)];
-	size_t len;
-
-	if ((len = strnlen(name, 16)) > 15) return ERANGE;
-
-	if (thread == pthread_self())
-		return prctl(PR_SET_NAME, (unsigned long)name, 0UL, 0UL, 0UL) ? errno : 0;
-
-	snprintf(f, sizeof f, "/proc/self/task/%d/comm", thread->tid);
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-	if ((fd = open(f, O_WRONLY)) < 0 || write(fd, name, len) < 0) status = errno;
-	if (fd >= 0) close(fd);
-	pthread_setcancelstate(cs, 0);
-	return status;
-}
diff --git a/src/thread/pthread_setschedparam.c b/src/thread/pthread_setschedparam.c
deleted file mode 100644
index 9e2fa456..00000000
--- a/src/thread/pthread_setschedparam.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param)
-{
-	int r;
-	LOCK(t->killlock);
-	r = t->dead ? ESRCH : -__syscall(SYS_sched_setscheduler, t->tid, policy, param);
-	UNLOCK(t->killlock);
-	return r;
-}
diff --git a/src/thread/pthread_setschedprio.c b/src/thread/pthread_setschedprio.c
deleted file mode 100644
index dc745b42..00000000
--- a/src/thread/pthread_setschedprio.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_setschedprio(pthread_t t, int prio)
-{
-	int r;
-	LOCK(t->killlock);
-	r = t->dead ? ESRCH : -__syscall(SYS_sched_setparam, t->tid, &prio);
-	UNLOCK(t->killlock);
-	return r;
-}
diff --git a/src/thread/pthread_setspecific.c b/src/thread/pthread_setspecific.c
deleted file mode 100644
index 55e46a89..00000000
--- a/src/thread/pthread_setspecific.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_setspecific(pthread_key_t k, const void *x)
-{
-	struct pthread *self = __pthread_self();
-	/* Avoid unnecessary COW */
-	if (self->tsd[k] != x) {
-		self->tsd[k] = (void *)x;
-		self->tsd_used = 1;
-	}
-	return 0;
-}
diff --git a/src/thread/pthread_sigmask.c b/src/thread/pthread_sigmask.c
deleted file mode 100644
index 88c333f6..00000000
--- a/src/thread/pthread_sigmask.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <signal.h>
-#include <errno.h>
-#include "syscall.h"
-
-int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
-{
-	int ret;
-	if ((unsigned)how - SIG_BLOCK > 2U) return EINVAL;
-	ret = -__syscall(SYS_rt_sigprocmask, how, set, old, _NSIG/8);
-	if (!ret && old) {
-		if (sizeof old->__bits[0] == 8) {
-			old->__bits[0] &= ~0x380000000ULL;
-		} else {
-			old->__bits[0] &= ~0x80000000UL;
-			old->__bits[1] &= ~0x3UL;
-		}
-	}
-	return ret;
-}
diff --git a/src/thread/pthread_spin_destroy.c b/src/thread/pthread_spin_destroy.c
deleted file mode 100644
index e65a820c..00000000
--- a/src/thread/pthread_spin_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_spin_destroy(pthread_spinlock_t *s)
-{
-	return 0;
-}
diff --git a/src/thread/pthread_spin_init.c b/src/thread/pthread_spin_init.c
deleted file mode 100644
index 681881cf..00000000
--- a/src/thread/pthread_spin_init.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_spin_init(pthread_spinlock_t *s, int shared)
-{
-	return *s = 0;
-}
diff --git a/src/thread/pthread_spin_lock.c b/src/thread/pthread_spin_lock.c
deleted file mode 100644
index ded2b653..00000000
--- a/src/thread/pthread_spin_lock.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include "pthread_impl.h"
-#include <errno.h>
-
-int pthread_spin_lock(pthread_spinlock_t *s)
-{
-	while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin();
-	return 0;
-}
diff --git a/src/thread/pthread_spin_trylock.c b/src/thread/pthread_spin_trylock.c
deleted file mode 100644
index 5284fdac..00000000
--- a/src/thread/pthread_spin_trylock.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-#include <errno.h>
-
-int pthread_spin_trylock(pthread_spinlock_t *s)
-{
-	return a_cas(s, 0, EBUSY);
-}
diff --git a/src/thread/pthread_spin_unlock.c b/src/thread/pthread_spin_unlock.c
deleted file mode 100644
index 724d9e0d..00000000
--- a/src/thread/pthread_spin_unlock.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "pthread_impl.h"
-
-int pthread_spin_unlock(pthread_spinlock_t *s)
-{
-	a_store(s, 0);
-	return 0;
-}
diff --git a/src/thread/pthread_testcancel.c b/src/thread/pthread_testcancel.c
deleted file mode 100644
index ee48e6d8..00000000
--- a/src/thread/pthread_testcancel.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "pthread_impl.h"
-#include "libc.h"
-
-static void dummy()
-{
-}
-
-weak_alias(dummy, __testcancel);
-
-void __pthread_testcancel()
-{
-	__testcancel();
-}
-
-weak_alias(__pthread_testcancel, pthread_testcancel);
diff --git a/src/thread/sem_destroy.c b/src/thread/sem_destroy.c
deleted file mode 100644
index f4aced5d..00000000
--- a/src/thread/sem_destroy.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <semaphore.h>
-
-int sem_destroy(sem_t *sem)
-{
-	return 0;
-}
diff --git a/src/thread/sem_getvalue.c b/src/thread/sem_getvalue.c
deleted file mode 100644
index d9d83071..00000000
--- a/src/thread/sem_getvalue.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <semaphore.h>
-
-int sem_getvalue(sem_t *restrict sem, int *restrict valp)
-{
-	int val = sem->__val[0];
-	*valp = val < 0 ? 0 : val;
-	return 0;
-}
diff --git a/src/thread/sem_init.c b/src/thread/sem_init.c
deleted file mode 100644
index 55092434..00000000
--- a/src/thread/sem_init.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include <semaphore.h>
-#include <limits.h>
-#include <errno.h>
-
-int sem_init(sem_t *sem, int pshared, unsigned value)
-{
-	if (value > SEM_VALUE_MAX) {
-		errno = EINVAL;
-		return -1;
-	}
-	sem->__val[0] = value;
-	sem->__val[1] = 0;
-	sem->__val[2] = pshared ? 0 : 128;
-	return 0;
-}
diff --git a/src/thread/sem_open.c b/src/thread/sem_open.c
deleted file mode 100644
index dc0279e8..00000000
--- a/src/thread/sem_open.c
+++ /dev/null
@@ -1,175 +0,0 @@
-#include <semaphore.h>
-#include <sys/mman.h>
-#include <limits.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdarg.h>
-#include <errno.h>
-#include <time.h>
-#include <stdio.h>
-#include <sys/stat.h>
-#include <stdlib.h>
-#include <pthread.h>
-#include "libc.h"
-
-char *__shm_mapname(const char *, char *);
-
-static struct {
-	ino_t ino;
-	sem_t *sem;
-	int refcnt;
-} *semtab;
-static volatile int lock[1];
-
-#define FLAGS (O_RDWR|O_NOFOLLOW|O_CLOEXEC|O_NONBLOCK)
-
-sem_t *sem_open(const char *name, int flags, ...)
-{
-	va_list ap;
-	mode_t mode;
-	unsigned value;
-	int fd, i, e, slot, first=1, cnt, cs;
-	sem_t newsem;
-	void *map;
-	char tmp[64];
-	struct timespec ts;
-	struct stat st;
-	char buf[NAME_MAX+10];
-
-	if (!(name = __shm_mapname(name, buf)))
-		return SEM_FAILED;
-
-	LOCK(lock);
-	/* Allocate table if we don't have one yet */
-	if (!semtab && !(semtab = calloc(sizeof *semtab, SEM_NSEMS_MAX))) {
-		UNLOCK(lock);
-		return SEM_FAILED;
-	}
-
-	/* Reserve a slot in case this semaphore is not mapped yet;
-	 * this is necessary because there is no way to handle
-	 * failures after creation of the file. */
-	slot = -1;
-	for (cnt=i=0; i<SEM_NSEMS_MAX; i++) {
-		cnt += semtab[i].refcnt;
-		if (!semtab[i].sem && slot < 0) slot = i;
-	}
-	/* Avoid possibility of overflow later */
-	if (cnt == INT_MAX || slot < 0) {
-		errno = EMFILE;
-		UNLOCK(lock);
-		return SEM_FAILED;
-	}
-	/* Dummy pointer to make a reservation */
-	semtab[slot].sem = (sem_t *)-1;
-	UNLOCK(lock);
-
-	flags &= (O_CREAT|O_EXCL);
-
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-
-	/* Early failure check for exclusive open; otherwise the case
-	 * where the semaphore already exists is expensive. */
-	if (flags == (O_CREAT|O_EXCL) && access(name, F_OK) == 0) {
-		errno = EEXIST;
-		goto fail;
-	}
-
-	for (;;) {
-		/* If exclusive mode is not requested, try opening an
-		 * existing file first and fall back to creation. */
-		if (flags != (O_CREAT|O_EXCL)) {
-			fd = open(name, FLAGS);
-			if (fd >= 0) {
-				if (fstat(fd, &st) < 0 ||
-				    (map = mmap(0, sizeof(sem_t), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) {
-					close(fd);
-					goto fail;
-				}
-				close(fd);
-				break;
-			}
-			if (errno != ENOENT)
-				goto fail;
-		}
-		if (!(flags & O_CREAT))
-			goto fail;
-		if (first) {
-			first = 0;
-			va_start(ap, flags);
-			mode = va_arg(ap, mode_t) & 0666;
-			value = va_arg(ap, unsigned);
-			va_end(ap);
-			if (value > SEM_VALUE_MAX) {
-				errno = EINVAL;
-				goto fail;
-			}
-			sem_init(&newsem, 1, value);
-		}
-		/* Create a temp file with the new semaphore contents
-		 * and attempt to atomically link it as the new name */
-		clock_gettime(CLOCK_REALTIME, &ts);
-		snprintf(tmp, sizeof(tmp), "/dev/shm/tmp-%d", (int)ts.tv_nsec);
-		fd = open(tmp, O_CREAT|O_EXCL|FLAGS, mode);
-		if (fd < 0) {
-			if (errno == EEXIST) continue;
-			goto fail;
-		}
-		if (write(fd, &newsem, sizeof newsem) != sizeof newsem || fstat(fd, &st) < 0 ||
-		    (map = mmap(0, sizeof(sem_t), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) {
-			close(fd);
-			unlink(tmp);
-			goto fail;
-		}
-		close(fd);
-		e = link(tmp, name) ? errno : 0;
-		unlink(tmp);
-		if (!e) break;
-		munmap(map, sizeof(sem_t));
-		/* Failure is only fatal when doing an exclusive open;
-		 * otherwise, next iteration will try to open the
-		 * existing file. */
-		if (e != EEXIST || flags == (O_CREAT|O_EXCL))
-			goto fail;
-	}
-
-	/* See if the newly mapped semaphore is already mapped. If
-	 * so, unmap the new mapping and use the existing one. Otherwise,
-	 * add it to the table of mapped semaphores. */
-	LOCK(lock);
-	for (i=0; i<SEM_NSEMS_MAX && semtab[i].ino != st.st_ino; i++);
-	if (i<SEM_NSEMS_MAX) {
-		munmap(map, sizeof(sem_t));
-		semtab[slot].sem = 0;
-		slot = i;
-		map = semtab[i].sem;
-	}
-	semtab[slot].refcnt++;
-	semtab[slot].sem = map;
-	semtab[slot].ino = st.st_ino;
-	UNLOCK(lock);
-	pthread_setcancelstate(cs, 0);
-	return map;
-
-fail:
-	pthread_setcancelstate(cs, 0);
-	LOCK(lock);
-	semtab[slot].sem = 0;
-	UNLOCK(lock);
-	return SEM_FAILED;
-}
-
-int sem_close(sem_t *sem)
-{
-	int i;
-	LOCK(lock);
-	for (i=0; i<SEM_NSEMS_MAX && semtab[i].sem != sem; i++);
-	if (!--semtab[i].refcnt) {
-		semtab[i].sem = 0;
-		semtab[i].ino = 0;
-	}
-	UNLOCK(lock);
-	munmap(sem, sizeof *sem);
-	return 0;
-}
diff --git a/src/thread/sem_post.c b/src/thread/sem_post.c
deleted file mode 100644
index 31e3293d..00000000
--- a/src/thread/sem_post.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <semaphore.h>
-#include "pthread_impl.h"
-
-int sem_post(sem_t *sem)
-{
-	int val, waiters, priv = sem->__val[2];
-	do {
-		val = sem->__val[0];
-		waiters = sem->__val[1];
-		if (val == SEM_VALUE_MAX) {
-			errno = EOVERFLOW;
-			return -1;
-		}
-	} while (a_cas(sem->__val, val, val+1+(val<0)) != val);
-	if (val<0 || waiters) __wake(sem->__val, 1, priv);
-	return 0;
-}
diff --git a/src/thread/sem_timedwait.c b/src/thread/sem_timedwait.c
deleted file mode 100644
index 8132eb1b..00000000
--- a/src/thread/sem_timedwait.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <semaphore.h>
-#include "pthread_impl.h"
-
-static void cleanup(void *p)
-{
-	a_dec(p);
-}
-
-int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
-{
-	pthread_testcancel();
-
-	if (!sem_trywait(sem)) return 0;
-
-	int spins = 100;
-	while (spins-- && sem->__val[0] <= 0 && !sem->__val[1]) a_spin();
-
-	while (sem_trywait(sem)) {
-		int r;
-		a_inc(sem->__val+1);
-		a_cas(sem->__val, 0, -1);
-		pthread_cleanup_push(cleanup, (void *)(sem->__val+1));
-		r = __timedwait_cp(sem->__val, -1, CLOCK_REALTIME, at, sem->__val[2]);
-		pthread_cleanup_pop(1);
-		if (r && r != EINTR) {
-			errno = r;
-			return -1;
-		}
-	}
-	return 0;
-}
diff --git a/src/thread/sem_trywait.c b/src/thread/sem_trywait.c
deleted file mode 100644
index 04edf46b..00000000
--- a/src/thread/sem_trywait.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <semaphore.h>
-#include "pthread_impl.h"
-
-int sem_trywait(sem_t *sem)
-{
-	int val;
-	while ((val=sem->__val[0]) > 0) {
-		int new = val-1-(val==1 && sem->__val[1]);
-		if (a_cas(sem->__val, val, new)==val) return 0;
-	}
-	errno = EAGAIN;
-	return -1;
-}
diff --git a/src/thread/sem_unlink.c b/src/thread/sem_unlink.c
deleted file mode 100644
index c06134bd..00000000
--- a/src/thread/sem_unlink.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <semaphore.h>
-#include <sys/mman.h>
-
-int sem_unlink(const char *name)
-{
-	return shm_unlink(name);
-}
diff --git a/src/thread/sem_wait.c b/src/thread/sem_wait.c
deleted file mode 100644
index 264194f9..00000000
--- a/src/thread/sem_wait.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <semaphore.h>
-
-int sem_wait(sem_t *sem)
-{
-	return sem_timedwait(sem, 0);
-}
diff --git a/src/thread/synccall.c b/src/thread/synccall.c
deleted file mode 100644
index ba2f258e..00000000
--- a/src/thread/synccall.c
+++ /dev/null
@@ -1,178 +0,0 @@
-#include "pthread_impl.h"
-#include <semaphore.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <string.h>
-#include <ctype.h>
-#include "futex.h"
-#include "atomic.h"
-#include "../dirent/__dirent.h"
-
-static struct chain {
-	struct chain *next;
-	int tid;
-	sem_t target_sem, caller_sem;
-} *volatile head;
-
-static volatile int synccall_lock[1];
-static volatile int target_tid;
-static void (*callback)(void *), *context;
-static volatile int dummy = 0;
-weak_alias(dummy, __block_new_threads);
-
-static void handler(int sig)
-{
-	struct chain ch;
-	int old_errno = errno;
-
-	sem_init(&ch.target_sem, 0, 0);
-	sem_init(&ch.caller_sem, 0, 0);
-
-	ch.tid = __syscall(SYS_gettid);
-
-	do ch.next = head;
-	while (a_cas_p(&head, ch.next, &ch) != ch.next);
-
-	if (a_cas(&target_tid, ch.tid, 0) == (ch.tid | 0x80000000))
-		__syscall(SYS_futex, &target_tid, FUTEX_UNLOCK_PI|FUTEX_PRIVATE);
-
-	sem_wait(&ch.target_sem);
-	callback(context);
-	sem_post(&ch.caller_sem);
-	sem_wait(&ch.target_sem);
-
-	errno = old_errno;
-}
-
-void __synccall(void (*func)(void *), void *ctx)
-{
-	sigset_t oldmask;
-	int cs, i, r, pid, self;;
-	DIR dir = {0};
-	struct dirent *de;
-	struct sigaction sa = { .sa_flags = SA_RESTART, .sa_handler = handler };
-	struct chain *cp, *next;
-	struct timespec ts;
-
-	/* Blocking signals in two steps, first only app-level signals
-	 * before taking the lock, then all signals after taking the lock,
-	 * is necessary to achieve AS-safety. Blocking them all first would
-	 * deadlock if multiple threads called __synccall. Waiting to block
-	 * any until after the lock would allow re-entry in the same thread
-	 * with the lock already held. */
-	__block_app_sigs(&oldmask);
-	LOCK(synccall_lock);
-	__block_all_sigs(0);
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-
-	head = 0;
-
-	if (!libc.threaded) goto single_threaded;
-
-	callback = func;
-	context = ctx;
-
-	/* This atomic store ensures that any signaled threads will see the
-	 * above stores, and prevents more than a bounded number of threads,
-	 * those already in pthread_create, from creating new threads until
-	 * the value is cleared to zero again. */
-	a_store(&__block_new_threads, 1);
-
-	/* Block even implementation-internal signals, so that nothing
-	 * interrupts the SIGSYNCCALL handlers. The main possible source
-	 * of trouble is asynchronous cancellation. */
-	memset(&sa.sa_mask, -1, sizeof sa.sa_mask);
-	__libc_sigaction(SIGSYNCCALL, &sa, 0);
-
-	pid = __syscall(SYS_getpid);
-	self = __syscall(SYS_gettid);
-
-	/* Since opendir is not AS-safe, the DIR needs to be setup manually
-	 * in automatic storage. Thankfully this is easy. */
-	dir.fd = open("/proc/self/task", O_RDONLY|O_DIRECTORY|O_CLOEXEC);
-	if (dir.fd < 0) goto out;
-
-	/* Initially send one signal per counted thread. But since we can't
-	 * synchronize with thread creation/exit here, there could be too
-	 * few signals. This initial signaling is just an optimization, not
-	 * part of the logic. */
-	for (i=libc.threads_minus_1; i; i--)
-		__syscall(SYS_kill, pid, SIGSYNCCALL);
-
-	/* Loop scanning the kernel-provided thread list until it shows no
-	 * threads that have not already replied to the signal. */
-	for (;;) {
-		int miss_cnt = 0;
-		while ((de = readdir(&dir))) {
-			if (!isdigit(de->d_name[0])) continue;
-			int tid = atoi(de->d_name);
-			if (tid == self || !tid) continue;
-
-			/* Set the target thread as the PI futex owner before
-			 * checking if it's in the list of caught threads. If it
-			 * adds itself to the list after we check for it, then
-			 * it will see its own tid in the PI futex and perform
-			 * the unlock operation. */
-			a_store(&target_tid, tid);
-
-			/* Thread-already-caught is a success condition. */
-			for (cp = head; cp && cp->tid != tid; cp=cp->next);
-			if (cp) continue;
-
-			r = -__syscall(SYS_tgkill, pid, tid, SIGSYNCCALL);
-
-			/* Target thread exit is a success condition. */
-			if (r == ESRCH) continue;
-
-			/* The FUTEX_LOCK_PI operation is used to loan priority
-			 * to the target thread, which otherwise may be unable
-			 * to run. Timeout is necessary because there is a race
-			 * condition where the tid may be reused by a different
-			 * process. */
-			clock_gettime(CLOCK_REALTIME, &ts);
-			ts.tv_nsec += 10000000;
-			if (ts.tv_nsec >= 1000000000) {
-				ts.tv_sec++;
-				ts.tv_nsec -= 1000000000;
-			}
-			r = -__syscall(SYS_futex, &target_tid,
-				FUTEX_LOCK_PI|FUTEX_PRIVATE, 0, &ts);
-
-			/* Obtaining the lock means the thread responded. ESRCH
-			 * means the target thread exited, which is okay too. */
-			if (!r || r == ESRCH) continue;
-
-			miss_cnt++;
-		}
-		if (!miss_cnt) break;
-		rewinddir(&dir);
-	}
-	close(dir.fd);
-
-	/* Serialize execution of callback in caught threads. */
-	for (cp=head; cp; cp=cp->next) {
-		sem_post(&cp->target_sem);
-		sem_wait(&cp->caller_sem);
-	}
-
-	sa.sa_handler = SIG_IGN;
-	__libc_sigaction(SIGSYNCCALL, &sa, 0);
-
-single_threaded:
-	func(ctx);
-
-	/* Only release the caught threads once all threads, including the
-	 * caller, have returned from the callback function. */
-	for (cp=head; cp; cp=next) {
-		next = cp->next;
-		sem_post(&cp->target_sem);
-	}
-
-out:
-	a_store(&__block_new_threads, 0);
-	__wake(&__block_new_threads, -1, 1);
-
-	pthread_setcancelstate(cs, 0);
-	UNLOCK(synccall_lock);
-	__restore_sigs(&oldmask);
-}
diff --git a/src/thread/thrd_sleep.c b/src/thread/thrd_sleep.c
deleted file mode 100644
index e8dfe400..00000000
--- a/src/thread/thrd_sleep.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <threads.h>
-#include <errno.h>
-#include "syscall.h"
-
-int thrd_sleep(const struct timespec *req, struct timespec *rem)
-{
-	int ret = __syscall(SYS_nanosleep, req, rem);
-	switch (ret) {
-	case 0:      return 0;
-	case -EINTR: return -1; /* value specified by C11 */
-	default:     return -2;
-	}
-}
diff --git a/src/thread/thrd_yield.c b/src/thread/thrd_yield.c
deleted file mode 100644
index f7ad1321..00000000
--- a/src/thread/thrd_yield.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <threads.h>
-#include "syscall.h"
-
-void thrd_yield()
-{
-	__syscall(SYS_sched_yield);
-}
diff --git a/src/thread/vmlock.c b/src/thread/vmlock.c
deleted file mode 100644
index 75f3cb76..00000000
--- a/src/thread/vmlock.c
+++ /dev/null
@@ -1,21 +0,0 @@
-#include "pthread_impl.h"
-
-static volatile int vmlock[2];
-
-void __vm_wait()
-{
-	int tmp;
-	while ((tmp=vmlock[0]))
-		__wait(vmlock, vmlock+1, tmp, 1);
-}
-
-void __vm_lock()
-{
-	a_inc(vmlock);
-}
-
-void __vm_unlock()
-{
-	if (a_fetch_add(vmlock, -1)==1 && vmlock[1])
-		__wake(vmlock, -1, 1);
-}
diff --git a/src/time/__map_file.c b/src/time/__map_file.c
index b91eb8ed..8f5d1b08 100644
--- a/src/time/__map_file.c
+++ b/src/time/__map_file.c
@@ -7,6 +7,8 @@ void *__mmap(void *, size_t, int, int, int, off_t);
 
 const char unsigned *__map_file(const char *pathname, size_t *size)
 {
+/*
+// TODO: implement
 	struct stat st;
 	const unsigned char *map = MAP_FAILED;
 	int fd = __sys_open(pathname, O_RDONLY|O_CLOEXEC|O_NONBLOCK);
@@ -17,4 +19,6 @@ const char unsigned *__map_file(const char *pathname, size_t *size)
 	}
 	__syscall(SYS_close, fd);
 	return map == MAP_FAILED ? 0 : map;
+*/
+	return 0;
 }
diff --git a/src/time/__tz.c b/src/time/__tz.c
index 1dbb0b8f..f4e54240 100644
--- a/src/time/__tz.c
+++ b/src/time/__tz.c
@@ -150,7 +150,7 @@ static void do_tzset()
 	 * standard path will be searched. */
 	if (*s == ':' || ((p=strchr(s, '/')) && !memchr(s, ',', p-s))) {
 		if (*s == ':') s++;
-		if (*s == '/' || *s == '.') {
+/*		if (*s == '/' || *s == '.') {
 			if (!libc.secure || !strcmp(s, "/etc/localtime"))
 				map = __map_file(s, &map_size);
 		} else {
@@ -164,7 +164,7 @@ static void do_tzset()
 					map = __map_file(pathname-l, &map_size);
 				}
 			}
-		}
+		}*/
 		if (!map) s = __utc;
 	}
 	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
diff --git a/src/time/clock_getcpuclockid.c b/src/time/clock_getcpuclockid.c
deleted file mode 100644
index 8a0e2d4c..00000000
--- a/src/time/clock_getcpuclockid.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <time.h>
-#include <errno.h>
-#include <unistd.h>
-#include "syscall.h"
-
-int clock_getcpuclockid(pid_t pid, clockid_t *clk)
-{
-	struct timespec ts;
-	clockid_t id = (-pid-1)*8U + 2;
-	int ret = __syscall(SYS_clock_getres, id, &ts);
-	if (ret) return -ret;
-	*clk = id;
-	return 0;
-}
diff --git a/src/time/clock_getres.c b/src/time/clock_getres.c
deleted file mode 100644
index 36a0d695..00000000
--- a/src/time/clock_getres.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <time.h>
-#include "syscall.h"
-
-int clock_getres(clockid_t clk, struct timespec *ts)
-{
-	return syscall(SYS_clock_getres, clk, ts);
-}
diff --git a/src/time/clock_gettime.c b/src/time/clock_gettime.c
index 24128804..9fc0162b 100644
--- a/src/time/clock_gettime.c
+++ b/src/time/clock_gettime.c
@@ -43,6 +43,8 @@ int __clock_gettime(clockid_t clk, struct timespec *ts)
 	}
 #endif
 
+/*
+	// TODO: implement
 	r = __syscall(SYS_clock_gettime, clk, ts);
 	if (r == -ENOSYS) {
 		if (clk == CLOCK_REALTIME) {
@@ -53,6 +55,8 @@ int __clock_gettime(clockid_t clk, struct timespec *ts)
 		r = -EINVAL;
 	}
 	return __syscall_ret(r);
+*/
+	return -1;
 }
 
 weak_alias(__clock_gettime, clock_gettime);
diff --git a/src/time/clock_nanosleep.c b/src/time/clock_nanosleep.c
deleted file mode 100644
index 9e4d9f1f..00000000
--- a/src/time/clock_nanosleep.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <time.h>
-#include <errno.h>
-#include "syscall.h"
-#include "libc.h"
-
-int clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct timespec *rem)
-{
-	int r = -__syscall_cp(SYS_clock_nanosleep, clk, flags, req, rem);
-	return clk == CLOCK_THREAD_CPUTIME_ID ? EINVAL : r;
-}
diff --git a/src/time/clock_settime.c b/src/time/clock_settime.c
deleted file mode 100644
index 66b8162d..00000000
--- a/src/time/clock_settime.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <time.h>
-#include "syscall.h"
-
-int clock_settime(clockid_t clk, const struct timespec *ts)
-{
-	return syscall(SYS_clock_settime, clk, ts);
-}
diff --git a/src/time/nanosleep.c b/src/time/nanosleep.c
index a2ff4839..584423d5 100644
--- a/src/time/nanosleep.c
+++ b/src/time/nanosleep.c
@@ -4,5 +4,9 @@
 
 int nanosleep(const struct timespec *req, struct timespec *rem)
 {
+/*
+// TODO: implement
 	return syscall_cp(SYS_nanosleep, req, rem);
+*/
+	return -1;
 }
diff --git a/src/time/time.c b/src/time/time.c
index 4b95e752..4e0bc20f 100644
--- a/src/time/time.c
+++ b/src/time/time.c
@@ -1,3 +1,4 @@
+// TODO:implemnt
 #include <time.h>
 #include "syscall.h"
 
@@ -5,8 +6,9 @@ int __clock_gettime(clockid_t, struct timespec *);
 
 time_t time(time_t *t)
 {
-	struct timespec ts;
-	__clock_gettime(CLOCK_REALTIME, &ts);
-	if (t) *t = ts.tv_sec;
-	return ts.tv_sec;
+//	struct timespec ts;
+//	__clock_gettime(CLOCK_REALTIME, &ts);
+//	if (t) *t = ts.tv_sec;
+//	return ts.tv_sec;
+	return 0;
 }
diff --git a/src/time/timer_create.c b/src/time/timer_create.c
deleted file mode 100644
index 16432bec..00000000
--- a/src/time/timer_create.c
+++ /dev/null
@@ -1,141 +0,0 @@
-#include <time.h>
-#include <setjmp.h>
-#include "pthread_impl.h"
-
-struct ksigevent {
-	union sigval sigev_value;
-	int sigev_signo;
-	int sigev_notify;
-	int sigev_tid;
-};
-
-struct start_args {
-	pthread_barrier_t b;
-	struct sigevent *sev;
-};
-
-static void dummy_0()
-{
-}
-weak_alias(dummy_0, __pthread_tsd_run_dtors);
-
-void __reset_tls();
-
-static void cleanup_fromsig(void *p)
-{
-	pthread_t self = __pthread_self();
-	__pthread_tsd_run_dtors(self);
-	self->cancel = 0;
-	self->cancelbuf = 0;
-	self->canceldisable = 0;
-	self->cancelasync = 0;
-	self->unblock_cancel = 0;
-	__reset_tls();
-	longjmp(p, 1);
-}
-
-static void timer_handler(int sig, siginfo_t *si, void *ctx)
-{
-	pthread_t self = __pthread_self();
-	jmp_buf jb;
-	void (*notify)(union sigval) = (void (*)(union sigval))self->start;
-	union sigval val = { .sival_ptr = self->start_arg };
-
-	if (!setjmp(jb) && si->si_code == SI_TIMER) {
-		pthread_cleanup_push(cleanup_fromsig, jb);
-		notify(val);
-		pthread_cleanup_pop(1);
-	}
-}
-
-static void install_handler()
-{
-	struct sigaction sa = {
-		.sa_sigaction = timer_handler,
-		.sa_flags = SA_SIGINFO | SA_RESTART
-	};
-	__libc_sigaction(SIGTIMER, &sa, 0);
-}
-
-static void *start(void *arg)
-{
-	pthread_t self = __pthread_self();
-	struct start_args *args = arg;
-	int id;
-
-	/* Reuse no-longer-needed thread structure fields to avoid
-	 * needing the timer address in the signal handler. */
-	self->start = (void *(*)(void *))args->sev->sigev_notify_function;
-	self->start_arg = args->sev->sigev_value.sival_ptr;
-
-	pthread_barrier_wait(&args->b);
-	if ((id = self->timer_id) >= 0) {
-		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
-			SIGTIMER_SET, 0, _NSIG/8);
-		__wait(&self->timer_id, 0, id, 1);
-		__syscall(SYS_timer_delete, id);
-	}
-	return 0;
-}
-
-int timer_create(clockid_t clk, struct sigevent *restrict evp, timer_t *restrict res)
-{
-	static pthread_once_t once = PTHREAD_ONCE_INIT;
-	pthread_t td;
-	pthread_attr_t attr;
-	int r;
-	struct start_args args;
-	struct ksigevent ksev, *ksevp=0;
-	int timerid;
-	sigset_t set;
-
-	switch (evp ? evp->sigev_notify : SIGEV_SIGNAL) {
-	case SIGEV_NONE:
-	case SIGEV_SIGNAL:
-		if (evp) {
-			ksev.sigev_value = evp->sigev_value;
-			ksev.sigev_signo = evp->sigev_signo;
-			ksev.sigev_notify = evp->sigev_notify;
-			ksev.sigev_tid = 0;
-			ksevp = &ksev;
-		}
-		if (syscall(SYS_timer_create, clk, ksevp, &timerid) < 0)
-			return -1;
-		*res = (void *)(intptr_t)timerid;
-		break;
-	case SIGEV_THREAD:
-		pthread_once(&once, install_handler);
-		if (evp->sigev_notify_attributes)
-			attr = *evp->sigev_notify_attributes;
-		else
-			pthread_attr_init(&attr);
-		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		pthread_barrier_init(&args.b, 0, 2);
-		args.sev = evp;
-
-		__block_app_sigs(&set);
-		r = pthread_create(&td, &attr, start, &args);
-		__restore_sigs(&set);
-		if (r) {
-			errno = r;
-			return -1;
-		}
-
-		ksev.sigev_value.sival_ptr = 0;
-		ksev.sigev_signo = SIGTIMER;
-		ksev.sigev_notify = 4; /* SIGEV_THREAD_ID */
-		ksev.sigev_tid = td->tid;
-		if (syscall(SYS_timer_create, clk, &ksev, &timerid) < 0)
-			timerid = -1;
-		td->timer_id = timerid;
-		pthread_barrier_wait(&args.b);
-		if (timerid < 0) return -1;
-		*res = (void *)(INTPTR_MIN | (uintptr_t)td>>1);
-		break;
-	default:
-		errno = EINVAL;
-		return -1;
-	}
-
-	return 0;
-}
diff --git a/src/time/timer_delete.c b/src/time/timer_delete.c
deleted file mode 100644
index 7c97eeb1..00000000
--- a/src/time/timer_delete.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <time.h>
-#include <limits.h>
-#include "pthread_impl.h"
-
-int timer_delete(timer_t t)
-{
-	if ((intptr_t)t < 0) {
-		pthread_t td = (void *)((uintptr_t)t << 1);
-		a_store(&td->timer_id, td->timer_id | INT_MIN);
-		__wake(&td->timer_id, 1, 1);
-		return 0;
-	}
-	return __syscall(SYS_timer_delete, t);
-}
diff --git a/src/time/timer_getoverrun.c b/src/time/timer_getoverrun.c
deleted file mode 100644
index e7f891e4..00000000
--- a/src/time/timer_getoverrun.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <time.h>
-#include <limits.h>
-#include "pthread_impl.h"
-
-int timer_getoverrun(timer_t t)
-{
-	if ((intptr_t)t < 0) {
-		pthread_t td = (void *)((uintptr_t)t << 1);
-		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
-	}
-	return syscall(SYS_timer_getoverrun, t);
-}
diff --git a/src/time/timer_gettime.c b/src/time/timer_gettime.c
deleted file mode 100644
index ed6d8d65..00000000
--- a/src/time/timer_gettime.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <time.h>
-#include <limits.h>
-#include "pthread_impl.h"
-
-int timer_gettime(timer_t t, struct itimerspec *val)
-{
-	if ((intptr_t)t < 0) {
-		pthread_t td = (void *)((uintptr_t)t << 1);
-		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
-	}
-	return syscall(SYS_timer_gettime, t, val);
-}
diff --git a/src/time/timer_settime.c b/src/time/timer_settime.c
deleted file mode 100644
index 62631aa4..00000000
--- a/src/time/timer_settime.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <time.h>
-#include <limits.h>
-#include "pthread_impl.h"
-
-int timer_settime(timer_t t, int flags, const struct itimerspec *restrict val, struct itimerspec *restrict old)
-{
-	if ((intptr_t)t < 0) {
-		pthread_t td = (void *)((uintptr_t)t << 1);
-		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
-	}
-	return syscall(SYS_timer_settime, t, flags, val, old);
-}
diff --git a/src/time/times.c b/src/time/times.c
index c4a100f7..4ebbb2de 100644
--- a/src/time/times.c
+++ b/src/time/times.c
@@ -3,5 +3,9 @@
 
 clock_t times(struct tms *tms)
 {
+/*
+// TODO:implemnt
 	return __syscall(SYS_times, tms);
+*/
+	return -1;
 }
diff --git a/src/unistd/access.c b/src/unistd/access.c
index d6eed683..466ab93f 100644
--- a/src/unistd/access.c
+++ b/src/unistd/access.c
@@ -4,9 +4,13 @@
 
 int access(const char *filename, int amode)
 {
+/*
+// TODO: implement
 #ifdef SYS_access
 	return syscall(SYS_access, filename, amode);
 #else
 	return syscall(SYS_faccessat, AT_FDCWD, filename, amode, 0);
 #endif
+*/
+	return -1;
 }
diff --git a/src/unistd/acct.c b/src/unistd/acct.c
index f6f25a8a..bbae69cb 100644
--- a/src/unistd/acct.c
+++ b/src/unistd/acct.c
@@ -5,5 +5,6 @@
 
 int acct(const char *filename)
 {
-	return syscall(SYS_acct, filename);
+// TODO: implement	return syscall(SYS_acct, filename);
+	return -1;
 }
diff --git a/src/unistd/alarm.c b/src/unistd/alarm.c
index 2e3263ac..e2efe20b 100644
--- a/src/unistd/alarm.c
+++ b/src/unistd/alarm.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <sys/time.h>
 #include "syscall.h"
@@ -8,3 +10,4 @@ unsigned alarm(unsigned seconds)
 	__syscall(SYS_setitimer, ITIMER_REAL, &it, &it);
 	return it.it_value.tv_sec + !!it.it_value.tv_usec;
 }
+*/
diff --git a/src/unistd/chdir.c b/src/unistd/chdir.c
index 5ba78b63..da51acea 100644
--- a/src/unistd/chdir.c
+++ b/src/unistd/chdir.c
@@ -1,7 +1,10 @@
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 
 int chdir(const char *path)
 {
-	return syscall(SYS_chdir, path);
+	return -1;
+//	return syscall(SYS_chdir, path);
 }
+
diff --git a/src/unistd/chown.c b/src/unistd/chown.c
index 14b03255..05b5d21b 100644
--- a/src/unistd/chown.c
+++ b/src/unistd/chown.c
@@ -4,9 +4,13 @@
 
 int chown(const char *path, uid_t uid, gid_t gid)
 {
+/*
+// TODO: implement
 #ifdef SYS_chown
 	return syscall(SYS_chown, path, uid, gid);
 #else
 	return syscall(SYS_fchownat, AT_FDCWD, path, uid, gid, 0);
 #endif
+*/
+	return -1;
 }
diff --git a/src/unistd/dup.c b/src/unistd/dup.c
index 7fee0120..8489a96e 100644
--- a/src/unistd/dup.c
+++ b/src/unistd/dup.c
@@ -3,5 +3,9 @@
 
 int dup(int fd)
 {
+/*
+// TODO: implement
 	return syscall(SYS_dup, fd);
+*/
+	return -1;
 }
diff --git a/src/unistd/dup2.c b/src/unistd/dup2.c
index 8f43c6dd..136d5a76 100644
--- a/src/unistd/dup2.c
+++ b/src/unistd/dup2.c
@@ -5,6 +5,8 @@
 
 int dup2(int old, int new)
 {
+/*
+// TODO: implement
 	int r;
 #ifdef SYS_dup2
 	while ((r=__syscall(SYS_dup2, old, new))==-EBUSY);
@@ -17,4 +19,6 @@ int dup2(int old, int new)
 	}
 #endif
 	return __syscall_ret(r);
+*/
+	return -1;
 }
diff --git a/src/unistd/dup3.c b/src/unistd/dup3.c
index 0eb6caf5..893fceff 100644
--- a/src/unistd/dup3.c
+++ b/src/unistd/dup3.c
@@ -7,6 +7,8 @@
 
 int __dup3(int old, int new, int flags)
 {
+/*
+// TODO: implement
 	int r;
 #ifdef SYS_dup2
 	if (old==new) return __syscall_ret(-EINVAL);
@@ -20,6 +22,8 @@ int __dup3(int old, int new, int flags)
 	while ((r=__syscall(SYS_dup3, old, new, flags))==-EBUSY);
 #endif
 	return __syscall_ret(r);
+*/
+	return -1;
 }
 
 weak_alias(__dup3, dup3);
diff --git a/src/unistd/faccessat.c b/src/unistd/faccessat.c
deleted file mode 100644
index 76bbd4c7..00000000
--- a/src/unistd/faccessat.c
+++ /dev/null
@@ -1,56 +0,0 @@
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-#include "syscall.h"
-#include "pthread_impl.h"
-
-struct ctx {
-	int fd;
-	const char *filename;
-	int amode;
-	int p;
-};
-
-static int checker(void *p)
-{
-	struct ctx *c = p;
-	int ret;
-	if (__syscall(SYS_setregid, __syscall(SYS_getegid), -1)
-	    || __syscall(SYS_setreuid, __syscall(SYS_geteuid), -1))
-		__syscall(SYS_exit, 1);
-	ret = __syscall(SYS_faccessat, c->fd, c->filename, c->amode, 0);
-	__syscall(SYS_write, c->p, &ret, sizeof ret);
-	return 0;
-}
-
-int faccessat(int fd, const char *filename, int amode, int flag)
-{
-	if (!flag || (flag==AT_EACCESS && getuid()==geteuid() && getgid()==getegid()))
-		return syscall(SYS_faccessat, fd, filename, amode, flag);
-
-	if (flag != AT_EACCESS)
-		return __syscall_ret(-EINVAL);
-
-	char stack[1024];
-	sigset_t set;
-	pid_t pid;
-	int status;
-	int ret, p[2];
-
-	if (pipe2(p, O_CLOEXEC)) return __syscall_ret(-EBUSY);
-	struct ctx c = { .fd = fd, .filename = filename, .amode = amode, .p = p[1] };
-
-	__block_all_sigs(&set);
-	
-	pid = __clone(checker, stack+sizeof stack, 0, &c);
-	__syscall(SYS_close, p[1]);
-
-	if (pid<0 || __syscall(SYS_read, p[0], &ret, sizeof ret) != sizeof(ret))
-		ret = -EBUSY;
-	__syscall(SYS_close, p[0]);
-	__syscall(SYS_wait4, pid, &status, __WCLONE, 0);
-
-	__restore_sigs(&set);
-
-	return __syscall_ret(ret);
-}
diff --git a/src/unistd/fchdir.c b/src/unistd/fchdir.c
index 72c3915e..a3eea7b0 100644
--- a/src/unistd/fchdir.c
+++ b/src/unistd/fchdir.c
@@ -7,6 +7,8 @@ void __procfdname(char *, unsigned);
 
 int fchdir(int fd)
 {
+/*
+// TODO: implement
 	int ret = __syscall(SYS_fchdir, fd);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
@@ -14,4 +16,6 @@ int fchdir(int fd)
 	char buf[15+3*sizeof(int)];
 	__procfdname(buf, fd);
 	return syscall(SYS_chdir, buf);
+*/
+	return -1;
 }
diff --git a/src/unistd/fchown.c b/src/unistd/fchown.c
index 75075eec..5d6620a6 100644
--- a/src/unistd/fchown.c
+++ b/src/unistd/fchown.c
@@ -7,6 +7,8 @@ void __procfdname(char *, unsigned);
 
 int fchown(int fd, uid_t uid, gid_t gid)
 {
+/*
+// TODO: implement
 	int ret = __syscall(SYS_fchown, fd, uid, gid);
 	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
 		return __syscall_ret(ret);
@@ -18,5 +20,7 @@ int fchown(int fd, uid_t uid, gid_t gid)
 #else
 	return syscall(SYS_fchownat, AT_FDCWD, buf, uid, gid, 0);
 #endif
+*/
 
+	return -1;
 }
diff --git a/src/unistd/fchownat.c b/src/unistd/fchownat.c
deleted file mode 100644
index 62457a3e..00000000
--- a/src/unistd/fchownat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <unistd.h>
-#include "syscall.h"
-
-int fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag)
-{
-	return syscall(SYS_fchownat, fd, path, uid, gid, flag);
-}
diff --git a/src/unistd/fdatasync.c b/src/unistd/fdatasync.c
index 3895ae53..fb53cf11 100644
--- a/src/unistd/fdatasync.c
+++ b/src/unistd/fdatasync.c
@@ -3,5 +3,9 @@
 
 int fdatasync(int fd)
 {
+/*
+// TODO: implement
 	return syscall_cp(SYS_fdatasync, fd);
+*/
+	return -1;
 }
diff --git a/src/unistd/fsync.c b/src/unistd/fsync.c
index 7a1c80b5..5dd265ca 100644
--- a/src/unistd/fsync.c
+++ b/src/unistd/fsync.c
@@ -3,5 +3,9 @@
 
 int fsync(int fd)
 {
+/*
+// TODO: implement
 	return syscall_cp(SYS_fsync, fd);
+	return -1;
+*/
 }
diff --git a/src/unistd/ftruncate.c b/src/unistd/ftruncate.c
index 467135f0..fa9dbeca 100644
--- a/src/unistd/ftruncate.c
+++ b/src/unistd/ftruncate.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -8,3 +10,4 @@ int ftruncate(int fd, off_t length)
 }
 
 LFS64(ftruncate);
+*/
diff --git a/src/unistd/getcwd.c b/src/unistd/getcwd.c
index 103fbbb5..e9977e6e 100644
--- a/src/unistd/getcwd.c
+++ b/src/unistd/getcwd.c
@@ -6,6 +6,9 @@
 
 char *getcwd(char *buf, size_t size)
 {
+	/*
+	// TODO: implement
+	*/
 	char tmp[PATH_MAX];
 	if (!buf) {
 		buf = tmp;
@@ -14,12 +17,17 @@ char *getcwd(char *buf, size_t size)
 		errno = EINVAL;
 		return 0;
 	}
-	long ret = syscall(SYS_getcwd, buf, size);
+	buf[0] = '/';
+	buf[1] = 0;
+//	long ret = syscall(SYS_getcwd, buf, size);
+/*
+	long ret = 0;
 	if (ret < 0)
 		return 0;
 	if (ret == 0 || buf[0] != '/') {
 		errno = ENOENT;
 		return 0;
 	}
+*/
 	return buf == tmp ? strdup(buf) : buf;
 }
diff --git a/src/unistd/getegid.c b/src/unistd/getegid.c
index 6287490d..104461ad 100644
--- a/src/unistd/getegid.c
+++ b/src/unistd/getegid.c
@@ -3,5 +3,9 @@
 
 gid_t getegid(void)
 {
+/*
+// TODO: implement
 	return __syscall(SYS_getegid);
+*/
+	return -1;
 }
diff --git a/src/unistd/geteuid.c b/src/unistd/geteuid.c
index 88f2cd53..4663b69c 100644
--- a/src/unistd/geteuid.c
+++ b/src/unistd/geteuid.c
@@ -3,5 +3,9 @@
 
 uid_t geteuid(void)
 {
+/*
+// TODO: implement
 	return __syscall(SYS_geteuid);
+*/
+	return -1;
 }
diff --git a/src/unistd/getgid.c b/src/unistd/getgid.c
index 1c9fe715..bbb569cb 100644
--- a/src/unistd/getgid.c
+++ b/src/unistd/getgid.c
@@ -3,5 +3,10 @@
 
 gid_t getgid(void)
 {
+/*
+// TODO: implement
 	return __syscall(SYS_getgid);
+
+*/
+	return -1;
 }
diff --git a/src/unistd/getgroups.c b/src/unistd/getgroups.c
index 0e6e63af..a867f4ad 100644
--- a/src/unistd/getgroups.c
+++ b/src/unistd/getgroups.c
@@ -3,5 +3,9 @@
 
 int getgroups(int count, gid_t list[])
 {
+/*
+// TODO: implement
 	return syscall(SYS_getgroups, count, list);
+*/
+	return -1;
 }
diff --git a/src/unistd/getpgid.c b/src/unistd/getpgid.c
index d295bfd5..f0045b54 100644
--- a/src/unistd/getpgid.c
+++ b/src/unistd/getpgid.c
@@ -3,5 +3,9 @@
 
 pid_t getpgid(pid_t pid)
 {
+/*
+// TODO: implement
 	return syscall(SYS_getpgid, pid);
+*/
+	return -1;
 }
diff --git a/src/unistd/getpgrp.c b/src/unistd/getpgrp.c
index 90e9bb07..18286efe 100644
--- a/src/unistd/getpgrp.c
+++ b/src/unistd/getpgrp.c
@@ -3,5 +3,9 @@
 
 pid_t getpgrp(void)
 {
+/*
+// TODO: implement
 	return __syscall(SYS_getpgid, 0);
+*/
+	return -1;
 }
diff --git a/src/unistd/getppid.c b/src/unistd/getppid.c
index 05cade53..4bf62e9b 100644
--- a/src/unistd/getppid.c
+++ b/src/unistd/getppid.c
@@ -3,5 +3,9 @@
 
 pid_t getppid(void)
 {
+/*
+// TODO: implement
 	return __syscall(SYS_getppid);
+*/
+	return -1;
 }
diff --git a/src/unistd/getsid.c b/src/unistd/getsid.c
index 93ba690e..9c3f2a3e 100644
--- a/src/unistd/getsid.c
+++ b/src/unistd/getsid.c
@@ -3,5 +3,9 @@
 
 pid_t getsid(pid_t pid)
 {
+/*
+// TODO: implement
 	return syscall(SYS_getsid, pid);
+*/
+	return -1;
 }
diff --git a/src/unistd/getuid.c b/src/unistd/getuid.c
index 61309d1b..210f8a21 100644
--- a/src/unistd/getuid.c
+++ b/src/unistd/getuid.c
@@ -1,7 +1,9 @@
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 
 uid_t getuid(void)
 {
-	return __syscall(SYS_getuid);
+//	return __syscall(SYS_getuid);
+	return 0;
 }
diff --git a/src/unistd/isatty.c b/src/unistd/isatty.c
index c8badaf5..360a0633 100644
--- a/src/unistd/isatty.c
+++ b/src/unistd/isatty.c
@@ -4,6 +4,10 @@
 
 int isatty(int fd)
 {
+// TODO: implement
+/*
 	struct winsize wsz;
 	return !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz);
+*/
+	return 1;
 }
diff --git a/src/unistd/lchown.c b/src/unistd/lchown.c
index ccd5ee02..5c8727bd 100644
--- a/src/unistd/lchown.c
+++ b/src/unistd/lchown.c
@@ -4,9 +4,13 @@
 
 int lchown(const char *path, uid_t uid, gid_t gid)
 {
+/*
+// TODO: implement
 #ifdef SYS_lchown
 	return syscall(SYS_lchown, path, uid, gid);
 #else
 	return syscall(SYS_fchownat, AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW);
 #endif
+*/
+	return -1;
 }
diff --git a/src/unistd/link.c b/src/unistd/link.c
index feec18e5..fa9ccfe4 100644
--- a/src/unistd/link.c
+++ b/src/unistd/link.c
@@ -4,9 +4,13 @@
 
 int link(const char *existing, const char *new)
 {
+/*
+// TODO: implement
 #ifdef SYS_link
 	return syscall(SYS_link, existing, new);
 #else
 	return syscall(SYS_linkat, AT_FDCWD, existing, AT_FDCWD, new, 0);
 #endif
+*/
+	return -1;
 }
diff --git a/src/unistd/linkat.c b/src/unistd/linkat.c
deleted file mode 100644
index 6a9a0b77..00000000
--- a/src/unistd/linkat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <unistd.h>
-#include "syscall.h"
-
-int linkat(int fd1, const char *existing, int fd2, const char *new, int flag)
-{
-	return syscall(SYS_linkat, fd1, existing, fd2, new, flag);
-}
diff --git a/src/unistd/pause.c b/src/unistd/pause.c
index 56eb171e..7890d930 100644
--- a/src/unistd/pause.c
+++ b/src/unistd/pause.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <signal.h>
 #include "syscall.h"
@@ -11,3 +13,4 @@ int pause(void)
 	return syscall_cp(SYS_ppoll, 0, 0, 0, 0);
 #endif
 }
+*/
diff --git a/src/unistd/pipe.c b/src/unistd/pipe.c
index d07b8d24..343a18a3 100644
--- a/src/unistd/pipe.c
+++ b/src/unistd/pipe.c
@@ -3,9 +3,13 @@
 
 int pipe(int fd[2])
 {
+/*
+// TODO: implement
 #ifdef SYS_pipe
 	return syscall(SYS_pipe, fd);
 #else
 	return syscall(SYS_pipe2, fd, 0);
 #endif
+*/
+	return -1;
 }
diff --git a/src/unistd/pipe2.c b/src/unistd/pipe2.c
index f24f74fb..3b2dc33b 100644
--- a/src/unistd/pipe2.c
+++ b/src/unistd/pipe2.c
@@ -1,3 +1,6 @@
+/*
+// TODO: implement
+
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -20,3 +23,4 @@ int pipe2(int fd[2], int flag)
 	}
 	return 0;
 }
+*/
diff --git a/src/unistd/pread.c b/src/unistd/pread.c
index 5483eb9d..63a71fd2 100644
--- a/src/unistd/pread.c
+++ b/src/unistd/pread.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -8,3 +10,4 @@ ssize_t pread(int fd, void *buf, size_t size, off_t ofs)
 }
 
 LFS64(pread);
+*/
diff --git a/src/unistd/preadv.c b/src/unistd/preadv.c
index 46d9ece7..b3d4666d 100644
--- a/src/unistd/preadv.c
+++ b/src/unistd/preadv.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _BSD_SOURCE
 #include <sys/uio.h>
 #include <unistd.h>
@@ -11,3 +13,4 @@ ssize_t preadv(int fd, const struct iovec *iov, int count, off_t ofs)
 }
 
 LFS64(preadv);
+*/
diff --git a/src/unistd/pwrite.c b/src/unistd/pwrite.c
index 4bf3d7df..7ea775ad 100644
--- a/src/unistd/pwrite.c
+++ b/src/unistd/pwrite.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -8,3 +10,4 @@ ssize_t pwrite(int fd, const void *buf, size_t size, off_t ofs)
 }
 
 LFS64(pwrite);
+*/
diff --git a/src/unistd/pwritev.c b/src/unistd/pwritev.c
index aec5d323..ddba40ac 100644
--- a/src/unistd/pwritev.c
+++ b/src/unistd/pwritev.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _BSD_SOURCE
 #include <sys/uio.h>
 #include <unistd.h>
@@ -11,3 +13,4 @@ ssize_t pwritev(int fd, const struct iovec *iov, int count, off_t ofs)
 }
 
 LFS64(pwritev);
+*/
diff --git a/src/unistd/readlink.c b/src/unistd/readlink.c
index a152d524..7aa3fce5 100644
--- a/src/unistd/readlink.c
+++ b/src/unistd/readlink.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
@@ -10,3 +12,4 @@ ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize)
 	return syscall(SYS_readlinkat, AT_FDCWD, path, buf, bufsize);
 #endif
 }
+*/
diff --git a/src/unistd/readlinkat.c b/src/unistd/readlinkat.c
deleted file mode 100644
index 9af45cd5..00000000
--- a/src/unistd/readlinkat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <unistd.h>
-#include "syscall.h"
-
-ssize_t readlinkat(int fd, const char *restrict path, char *restrict buf, size_t bufsize)
-{
-	return syscall(SYS_readlinkat, fd, path, buf, bufsize);
-}
diff --git a/src/unistd/readv.c b/src/unistd/readv.c
index e45cb484..7a6ec191 100644
--- a/src/unistd/readv.c
+++ b/src/unistd/readv.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/uio.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ ssize_t readv(int fd, const struct iovec *iov, int count)
 {
 	return syscall_cp(SYS_readv, fd, iov, count);
 }
+*/
diff --git a/src/unistd/renameat.c b/src/unistd/renameat.c
deleted file mode 100644
index 12574822..00000000
--- a/src/unistd/renameat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <stdio.h>
-#include "syscall.h"
-
-int renameat(int oldfd, const char *old, int newfd, const char *new)
-{
-	return syscall(SYS_renameat, oldfd, old, newfd, new);
-}
diff --git a/src/unistd/rmdir.c b/src/unistd/rmdir.c
index 6825ffc8..b7faf6ed 100644
--- a/src/unistd/rmdir.c
+++ b/src/unistd/rmdir.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
@@ -10,3 +12,4 @@ int rmdir(const char *path)
 	return syscall(SYS_unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
 #endif
 }
+*/
diff --git a/src/unistd/setegid.c b/src/unistd/setegid.c
index e6da2573..0241d544 100644
--- a/src/unistd/setegid.c
+++ b/src/unistd/setegid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "libc.h"
 #include "syscall.h"
@@ -6,3 +8,4 @@ int setegid(gid_t egid)
 {
 	return __setxid(SYS_setresgid, -1, egid, -1);
 }
+*/
diff --git a/src/unistd/seteuid.c b/src/unistd/seteuid.c
index ef8b9df4..d505cad5 100644
--- a/src/unistd/seteuid.c
+++ b/src/unistd/seteuid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int seteuid(uid_t euid)
 {
 	return __setxid(SYS_setresuid, -1, euid, -1);
 }
+*/
diff --git a/src/unistd/setgid.c b/src/unistd/setgid.c
index bae4616a..2d6831a9 100644
--- a/src/unistd/setgid.c
+++ b/src/unistd/setgid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int setgid(gid_t gid)
 {
 	return __setxid(SYS_setgid, gid, 0, 0);
 }
+*/
diff --git a/src/unistd/setpgid.c b/src/unistd/setpgid.c
index 06160695..c72beb82 100644
--- a/src/unistd/setpgid.c
+++ b/src/unistd/setpgid.c
@@ -3,5 +3,9 @@
 
 int setpgid(pid_t pid, pid_t pgid)
 {
+/*
+// TODO: implement
 	return syscall(SYS_setpgid, pid, pgid);
+*/
+	return -1;
 }
diff --git a/src/unistd/setpgrp.c b/src/unistd/setpgrp.c
index a2a37f65..3f7bae2e 100644
--- a/src/unistd/setpgrp.c
+++ b/src/unistd/setpgrp.c
@@ -1,6 +1,9 @@
+/*
+// TODO: implement
 #include <unistd.h>
 
 pid_t setpgrp(void)
 {
 	return setpgid(0, 0);
 }
+*/
diff --git a/src/unistd/setregid.c b/src/unistd/setregid.c
index f5a8972a..57bc9827 100644
--- a/src/unistd/setregid.c
+++ b/src/unistd/setregid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int setregid(gid_t rgid, gid_t egid)
 {
 	return __setxid(SYS_setregid, rgid, egid, 0);
 }
+*/
diff --git a/src/unistd/setresgid.c b/src/unistd/setresgid.c
index b9af540a..123d5893 100644
--- a/src/unistd/setresgid.c
+++ b/src/unistd/setresgid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
@@ -7,3 +9,4 @@ int setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
 	return __setxid(SYS_setresgid, rgid, egid, sgid);
 }
+*/
diff --git a/src/unistd/setresuid.c b/src/unistd/setresuid.c
index 83692b4c..2b2ae722 100644
--- a/src/unistd/setresuid.c
+++ b/src/unistd/setresuid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
@@ -7,3 +9,4 @@ int setresuid(uid_t ruid, uid_t euid, uid_t suid)
 {
 	return __setxid(SYS_setresuid, ruid, euid, suid);
 }
+*/
diff --git a/src/unistd/setreuid.c b/src/unistd/setreuid.c
index 3fcc59e2..287b2338 100644
--- a/src/unistd/setreuid.c
+++ b/src/unistd/setreuid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int setreuid(uid_t ruid, uid_t euid)
 {
 	return __setxid(SYS_setreuid, ruid, euid, 0);
 }
+*/
diff --git a/src/unistd/setsid.c b/src/unistd/setsid.c
index 609bbe4a..09d2ce02 100644
--- a/src/unistd/setsid.c
+++ b/src/unistd/setsid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ pid_t setsid(void)
 {
 	return syscall(SYS_setsid);
 }
+*/
diff --git a/src/unistd/setuid.c b/src/unistd/setuid.c
index 602ecbbf..ad39b9e3 100644
--- a/src/unistd/setuid.c
+++ b/src/unistd/setuid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ int setuid(uid_t uid)
 {
 	return __setxid(SYS_setuid, uid, 0, 0);
 }
+*/
diff --git a/src/unistd/setxid.c b/src/unistd/setxid.c
index 0239f8af..29f53c75 100644
--- a/src/unistd/setxid.c
+++ b/src/unistd/setxid.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <errno.h>
 #include "syscall.h"
@@ -15,11 +17,11 @@ static void do_setxid(void *p)
 	if (c->err>0) return;
 	int ret = -__syscall(c->nr, c->id, c->eid, c->sid);
 	if (ret && !c->err) {
-		/* If one thread fails to set ids after another has already
+*/		/* If one thread fails to set ids after another has already
 		 * succeeded, forcibly killing the process is the only safe
 		 * thing to do. State is inconsistent and dangerous. Use
 		 * SIGKILL because it is uncatchable. */
-		__block_all_sigs(0);
+/*		__block_all_sigs(0);
 		__syscall(SYS_kill, __syscall(SYS_getpid), SIGKILL);
 	}
 	c->err = ret;
@@ -27,9 +29,9 @@ static void do_setxid(void *p)
 
 int __setxid(int nr, int id, int eid, int sid)
 {
-	/* err is initially nonzero so that failure of the first thread does not
+*/	/* err is initially nonzero so that failure of the first thread does not
 	 * trigger the safety kill above. */
-	struct ctx c = { .nr = nr, .id = id, .eid = eid, .sid = sid, .err = -1 };
+/*	struct ctx c = { .nr = nr, .id = id, .eid = eid, .sid = sid, .err = -1 };
 	__synccall(do_setxid, &c);
 	if (c.err) {
 		if (c.err>0) errno = c.err;
@@ -37,3 +39,4 @@ int __setxid(int nr, int id, int eid, int sid)
 	}
 	return 0;
 }
+*/
diff --git a/src/unistd/symlink.c b/src/unistd/symlink.c
index 0973d78a..1b18090c 100644
--- a/src/unistd/symlink.c
+++ b/src/unistd/symlink.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include <fcntl.h>
 #include "syscall.h"
@@ -10,3 +12,4 @@ int symlink(const char *existing, const char *new)
 	return syscall(SYS_symlinkat, existing, AT_FDCWD, new);
 #endif
 }
+*/
diff --git a/src/unistd/symlinkat.c b/src/unistd/symlinkat.c
deleted file mode 100644
index d1c59b4d..00000000
--- a/src/unistd/symlinkat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <unistd.h>
-#include "syscall.h"
-
-int symlinkat(const char *existing, int fd, const char *new)
-{
-	return syscall(SYS_symlinkat, existing, fd, new);
-}
diff --git a/src/unistd/sync.c b/src/unistd/sync.c
index f18765aa..447550dd 100644
--- a/src/unistd/sync.c
+++ b/src/unistd/sync.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 
@@ -5,3 +7,4 @@ void sync(void)
 {
 	__syscall(SYS_sync);
 }
+*/
diff --git a/src/unistd/truncate.c b/src/unistd/truncate.c
index 8e65655c..fa03b9a6 100644
--- a/src/unistd/truncate.c
+++ b/src/unistd/truncate.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
@@ -8,3 +10,4 @@ int truncate(const char *path, off_t length)
 }
 
 LFS64(truncate);
+*/
diff --git a/src/unistd/unlinkat.c b/src/unistd/unlinkat.c
deleted file mode 100644
index e0e25d22..00000000
--- a/src/unistd/unlinkat.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <unistd.h>
-#include "syscall.h"
-
-int unlinkat(int fd, const char *path, int flag)
-{
-	return syscall(SYS_unlinkat, fd, path, flag);
-}
diff --git a/src/unistd/writev.c b/src/unistd/writev.c
index ef300ddf..f79a8a57 100644
--- a/src/unistd/writev.c
+++ b/src/unistd/writev.c
@@ -1,3 +1,5 @@
+/*
+// TODO: implement
 #include <sys/uio.h>
 #include "syscall.h"
 #include "libc.h"
@@ -6,3 +8,4 @@ ssize_t writev(int fd, const struct iovec *iov, int count)
 {
 	return syscall_cp(SYS_writev, fd, iov, count);
 }
+*/
